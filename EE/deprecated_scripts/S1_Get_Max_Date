// Find calendar day of year of maximum backscatter for an image collection representing 1 year 
// between years 2015 and 2021

//Import Atlantic Forest Feature Class
var AF = ee.FeatureCollection("users/brbell01/Masters/Atlantic_Forest");
//Map.addLayer(AF, {}, 'Atlantic Forest Biome')

var StudyArea = ee.FeatureCollection("users/brbell01/Masters/PN_Mata_Escura");
Map.addLayer(StudyArea, {}, 'PN Mata Escura')

Map.centerObject(StudyArea, 11);

//Import Sentinel-1 Image Collection
var S1 = ee.ImageCollection("COPERNICUS/S1_GRD_FLOAT");

//// Import Study Areas
var hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/1_MataEscura_Hectares");

// var StudyAreas = ee.Geometry.MultiPolygon([
//   [[[-41.05,-16.39],[-40.90,-16.39],[-40.90,-16.31],[-41.05, -16.31],[-41.05,-16.39]]],
//   [[[-39.41,-16.85],[-39.31,-16.85],[-39.31,-16.89],[-39.41,-16.89],[-39.41,-16.85]]]
//   ]);

//filter out edges from collection
var S1filtered = S1.filter(ee.Filter.date('2015-01-01', '2021-12-31'))
      .filter(ee.Filter.bounds(StudyArea))
      // .map(function(image) {
      //     var edge = image.lt(0);
      //     var maskedImage = image.mask().and(edge.not());
      //     return image.updateMask(maskedImage);
      //   });
        

var S1first = S1filtered.first().select(['VH']);
Map.addLayer(S1first,{min: 0, max: 0.2, gamma: 1.8}, 
  'First S1 Image')

//Select only VH and VV polarizations and separate orbits [No ascending orbit acquisitions]
var VHVV_desc = S1filtered.filter(ee.Filter.eq('instrumentMode', 'IW'))
        .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))
        .select(['VH','VV']);
        
// var VHVV_asc = S1filtered.filter(ee.Filter.eq('instrumentMode', 'IW'))
//         .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))
//         .select(['VH','VV']);

print(VHVV_desc.toList(1000))
// print(VHVV_asc.toList(1000))

// //Examine coverage of HH polarization [NO IMAGES]
// var HH_desc = S1filtered.filter(ee.Filter.eq('instrumentMode', 'IW'))
//         .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))
//         .select(['HH']);

// var HH_asc = S1filtered.filter(ee.Filter.eq('instrumentMode', 'IW'))
//         .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))
//         .select(['HH']);

// print(HH_desc.toList(1000))
// print(HH_asc.toList(1000))
// ////////////////////////////////////////////////


// //HH coverage anywhere in AF? [NO IMAGES]

// var HH_desc = S1.filter(ee.Filter.date('2015-01-01', '2021-12-31'))
//         .filter(ee.Filter.bounds(AF))
//         .filter(ee.Filter.eq('instrumentMode', 'IW'))
//         .filter(ee.Filter.eq('orbitProperties_pass', 'DESCENDING'))
//         .select(['HH']);

// var HH_asc = S1.filter(ee.Filter.date('2015-01-01', '2021-12-31'))
//         .filter(ee.Filter.bounds(AF))
//         .filter(ee.Filter.eq('instrumentMode', 'IW'))
//         .filter(ee.Filter.eq('orbitProperties_pass', 'ASCENDING'))
//         .select(['HH']);

// print(HH_desc.toList(1000))
// print(HH_asc.toList(1000))


// var VHVV_desc_list = S1filtered.toList(1000)
// var VHVV_asc_list = S1filtered.toList(1000)
// ////////////////////////////////////////////////


//To extract day value for further calculations, add a date band to each image 
//displaying the calendar day of year the image was acquired

// function addDateBand(image) {
//   // Get start time from image metadata and convert to day of year
//   var date = ee.Date(image.get('system:time_start')).format('DDD'); //something wrong here
//   // make image band
//   var dateimage = ee.Image([date]).double();
//   return image.addBands(dateimage);
// }

// var addDateBand = function(image){
//   var doy = image.date().getRelative('day', 'year');
//   var doyBand = ee.Image.constant(doy).uint16().rename('doy')
//   return image.addBands(doyBand);
// };

// //map over collection
// var dateCollection = VHVV_desc.map(addDateBand);
// //var dateCollection = VHVV_asc.map(addDateBand);


function addDateBand(image) {
  // Get start time from image metadata and convert to day of year
  var date = ee.Number.parse(ee.Date(image.get('system:time_start')).format('D')); //something wrong here

  // make image band
  var dateimage = ee.Image(date).double().rename('dayofyear');
  return image.addBands(dateimage);
}

//map over collection
var dateCollection = VHVV_desc.map(addDateBand);
print(dateCollection)

// //test
// print(ee.Date(dateCollection.first().get('system:time_start')));
// print(dateCollection);
// Map.addLayer(dateCollection.first());

//var normalizedImage = VHVV.first().select('VH').normalize(); //why can't I call the normalize function here, specified below? 
//Map.addLayer(normalizedImage);  


// Add a ratio band for image based on:
// Charbonneau, F. et al 2005. “Use of Dual Polarization and Multi-Incidence 
// SAR for Soil Permeability Mapping.” In Proceedings of the 2005 Advanced 
// Synthetic Aperture Radar (ASAR) Workshop, St-Hubert, QC, Canada, 15–17.

function combinedPols(image) {
  var RVI = image.expression(
    '4*a/(a+b)', {
      'a': image.select('VH'),
      'b': image.select('VV'),
}).rename('RVI')
  return image.addBands(RVI);
}

// Map the function over the VH collection
var ratioCollection_desc = VHVV_desc.map(combinedPols)
//var ratioCollection_asc = VHVV_asc.map(combinedPols)

print(ratioCollection_desc);

var firstRatioImage = ratioCollection_desc.first().clip(StudyArea)

Map.addLayer(firstRatioImage.select('VH'), {min: 0, max: 0.2, gamma: 1.8}, 'VH');
Map.addLayer(firstRatioImage.select('VV'), {min: 0, max: 0.2, gamma: 1.8}, 'VV');
Map.addLayer(firstRatioImage.select('RVI'), {min: 0, max: 0.2, gamma: 1.8}, 'RVI');

// Now calculate the reducer image containing day of year for MaxdB values
// var maxdBimage = ratioCollection
//   .reduce(ee.Reducer.max())
//   .copyProperties(image,['system:time_start','system:time_end'])


//############################
// Apply a Speckle Filter
//############################


// Function to convert from dB
function toNatural(img) {
  return ee.Image(10.0).pow(img.select(0).divide(10.0));
}

//Function to convert to dB
function toDB(img) {
  return ee.Image(img).log10().multiply(10.0);
}

//Apllying a Refined Lee Speckle filter as coded in the SNAP 3.0 S1TBX:

//https://github.com/senbox-org/s1tbx/blob/master/s1tbx-op-sar-processing/src/main/java/org/esa/s1tbx/sar/gpf/filtering/SpeckleFilters/RefinedLee.java
//Adapted by Guido Lemoine

// by Guido Lemoine

function RefinedLee(img) {
  // img must be in natural units, i.e. not in dB!
  // Set up 3x3 kernels 
  var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
  var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);

  // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
  var sample_weights = ee.List([[0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0], [0,1,0,1,0,1,0], [0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0]]);

  var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);

  // Calculate mean and variance for the sampled windows and store as 9 bands
  var sample_mean = mean3.neighborhoodToBands(sample_kernel); 
  var sample_var = variance3.neighborhoodToBands(sample_kernel);

  // Determine the 4 gradients for the sampled windows
  var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs();
  gradients = gradients.addBands(sample_mean.select(6).subtract(sample_mean.select(2)).abs());
  gradients = gradients.addBands(sample_mean.select(3).subtract(sample_mean.select(5)).abs());
  gradients = gradients.addBands(sample_mean.select(0).subtract(sample_mean.select(8)).abs());

  // And find the maximum gradient amongst gradient bands
  var max_gradient = gradients.reduce(ee.Reducer.max());

  // Create a mask for band pixels that are the maximum gradient
  var gradmask = gradients.eq(max_gradient);

  // duplicate gradmask bands: each gradient represents 2 directions
  gradmask = gradmask.addBands(gradmask);

  // Determine the 8 directions
  var directions = sample_mean.select(1).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(7))).multiply(1);
  directions = directions.addBands(sample_mean.select(6).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(2))).multiply(2));
  directions = directions.addBands(sample_mean.select(3).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(5))).multiply(3));
  directions = directions.addBands(sample_mean.select(0).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(8))).multiply(4));
  // The next 4 are the not() of the previous 4
  directions = directions.addBands(directions.select(0).not().multiply(5));
  directions = directions.addBands(directions.select(1).not().multiply(6));
  directions = directions.addBands(directions.select(2).not().multiply(7));
  directions = directions.addBands(directions.select(3).not().multiply(8));

  // Mask all values that are not 1-8
  directions = directions.updateMask(gradmask);

  // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
  directions = directions.reduce(ee.Reducer.sum());  

  //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
  //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);

  var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean));

  // Calculate localNoiseVariance
  var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5).arrayReduce(ee.Reducer.mean(), [0]);

  // Set up the 7*7 kernels for directional statistics
  var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3).cat(ee.List.repeat(ee.List.repeat(1,7),4));

  var diag_weights = ee.List([[1,0,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,0,0,0,0], 
    [1,1,1,1,0,0,0], [1,1,1,1,1,0,0], [1,1,1,1,1,1,0], [1,1,1,1,1,1,1]]);

  var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
  var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);

  // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
  var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel).updateMask(directions.eq(1));
  var dir_var = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel).updateMask(directions.eq(1));

  dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel).updateMask(directions.eq(2)));
  dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel).updateMask(directions.eq(2)));

  // and add the bands for rotated kernels
  for (var i=1; i<4; i++) {
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
  }

  // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
  dir_mean = dir_mean.reduce(ee.Reducer.sum());
  dir_var = dir_var.reduce(ee.Reducer.sum());

  // A finally generate the filtered value
  var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV)).divide(sigmaV.add(1.0));

  var b = varX.divide(dir_var);

  var result = dir_mean.add(b.multiply(img.subtract(dir_mean)));
  return(result.arrayFlatten([['sum']]));
}

var firstRatioImage_speck_VH = ee.Image(toDB(RefinedLee(toNatural(firstRatioImage.select('VH'))))).clip(StudyArea)
var firstRatioImage_speck_VV = ee.Image(toDB(RefinedLee(toNatural(firstRatioImage.select('VV'))))).clip(StudyArea)
var firstRatioImage_speck_VHVVratio = ee.Image(toDB(RefinedLee(toNatural(firstRatioImage.select('RVI'))))).clip(StudyArea)

Map.addLayer(firstRatioImage_speck_VH, {min: 0, max: 0.1, gamma: 1.8}, 'VH_smoothed');
Map.addLayer(firstRatioImage_speck_VV, {min: 0, max: 0.1, gamma: 1.8}, 'VV_smoothed');
Map.addLayer(firstRatioImage_speck_VHVVratio, {min: 0, max: 0.1, gamma: 1.8}, 'RVI_smoothed');

