// Sentinel-1 and IMERG rainfall, compute Cross-covariance and Cross-correlation 
// to determine dependence of rainfall and S1 backscatter on subsequent days

// Cross-covariance is analogous to auto-covariance, except instead of measuring the 
// correspondence between a variable and itself at a lag, it measure the correspondence between
// a variable and a covariate at a lag.  Specifically, define the cross-covariance and cross
// correlation according to Shumway and Stoffer (2017) equations 1.30 and 1.31, respectively.  


//Import study area and sampling plots
var AREA_NAME =  "REBIO Mata Escura, MG" , // "PNH Monte Pascoal, BA", // "REBIO Sooretama, ES" ; "PE Rio Doce, MG", "REBIO Mata Escura, MG"
    //Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/1_MataEscura_Hectares1"),
    Park = ee.FeatureCollection("projects/af-phenology/assets/Parks/REBIO_Mata_Escura");

Park = Park.geometry()
var roi = Park.centroid();

// var wrapper = require('users/brbell01/AF_Phenology:Sentinel-1/Wrapper');
// var helper = require('users/brbell01/AF_Phenology:Sentinel-1/Utilities');
// var helpers = require('users/brbell01/AF_Phenology:Helpers');
// var constants = require('users/brbell01/AF_Phenology:Constants');

var BAND_NAME = 'VH'

//Processed S1
// Define Sentinel-1 Parameters
var parameter = {//1. Data Selection
    START_DATE: "2016-01-01", //constants.STUDY_START_DATE
    STOP_DATE: "2022-01-01", // constants.STUDY_END_DATE
    POLARIZATION:'VVVH',
    ORBIT: 'DESCENDING',
    ORBIT_NUMBER: 155, //155
    GEOMETRY: roi,
    APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION: true,
    //3.Speckle filter
    APPLY_SPECKLE_FILTERING: true,
    SPECKLE_FILTER_FRAMEWORK: 'MULTI',
    SPECKLE_FILTER: 'LEE SIGMA',
    SPECKLE_FILTER_KERNEL_SIZE: 15,
    SPECKLE_FILTER_NR_OF_IMAGES: 5,
    //4. Radiometric terrain normalization
    APPLY_TERRAIN_FLATTENING: true,
    DEM: ee.Image('USGS/SRTMGL1_003'),
    TERRAIN_FLATTENING_MODEL: 'VOLUME',
    TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER: 100,
    //5. Output
    FORMAT : 'DB',
    CLIP_TO_ROI: false,
    SAVE_ASSETS: false,
    //6. Visualization
    VIS_BAND_RATIO: 'VHVV_ratio' // or 'RVI'
}

// //Preprocess the S1 collection
// var s1_preprocess = wrapper.s1_preproc(parameter);

// var s1 = s1_preprocess[0];
// s1_preprocess = s1_preprocess[1];

// //Filter to consistent orbit number
// s1_preprocess = s1_preprocess.filter(ee.Filter.eq('relativeOrbitNumber_start', 
//                 parameter.ORBIT_NUMBER));

// //Add ratio band   
// var s1_preprocess_view = s1_preprocess.map(helper.add_ratio_lin).map(helper.lin_to_db2)

//import IMERG daily rainfall

var rainfall = ee.ImageCollection('NASA/GPM_L3/IMERG_V06');
var nDays = ee.Number(ee.Date(parameter.STOP_DATE).difference(ee.Date(parameter.START_DATE), 'day'));

var dailyrain = ee.List.sequence(0, nDays.subtract(1)).map(function(n){
  var t1 = ee.Date(parameter.START_DATE).advance(ee.Number(n), 'day');
  var t2 = t1.advance(1, 'day');
  var dailymax = rainfall
      .filterDate(t1, t2)
      .select('precipitationCal')
      .max();
  return dailymax
    .set({'system:time_start': t1.millis()});
});

dailyrain = ee.ImageCollection(dailyrain)

// Display a time-series chart of sentinel-1 values with high precip values flagged

var chart = ui.Chart.image.series({
  imageCollection: dailyrain,                          // Image collection we want to use for timeseries analysis
  region: roi,                                            // plot boundaries
  reducer: ee.Reducer.median(),                                // Pixel we want to use
  scale: 100,                                       // [Spatial Resolution]: 500
  xProperty: 'system:time_start'                       // Date 
})
.setOptions({
title: 'IMERG Daily Maximum Precip. over ' + AREA_NAME,
legend: {position: 'none'},
hAxis: {title: '', format: 'YYYY-MMM-dd'},
vAxes: {0: {
      title: "Precip. (mm/Hr)",
      baseline: 0,
      titleTextStyle: {bold: true, color: 'blue'},
      viewWindow: { min: 0 }
    }
}
});


print(chart)


// // Estimate linear trend in S1 over time
// // List of the independent variable names
// var independents = ee.List(['constant', 't']);

// // Name of the dependent variable.
// var dependent = ee.String(BAND_NAME);

// // Compute a linear trend.  This will have two bands: 'residuals' and 
// // a 2x1 band called coefficients (columns are for dependent variables).
// var trend = s1_preprocess_view.select(independents.add(dependent))
//     .reduce(ee.Reducer.linearRegression(independents.length(), 1));
// // Map.addLayer(trend, {}, 'trend array image');

// // Flatten the coefficients into a 2-band image
// var coefficients = trend.select('coefficients')
//   .arrayProject([0])
//   .arrayFlatten([independents]);

// // The coefficients image is a two band image in which each pixel contains values for β0 and β1.   
// // Use the model to "detrend" the original S1 time series:

// // Compute a de-trended series.
// var detrended = s1_preprocess_view.map(function(image) {
//   return image.select(dependent).subtract(
//           image.select(independents).multiply(coefficients).reduce('sum'))
//           .rename(dependent)
//           .copyProperties(image, ['system:time_start']);
// });


// //function to create a lagged ImageCollection
// var lag = function(leftCollection, rightCollection, lagDays) {
//   var filter = ee.Filter.and(
//     ee.Filter.maxDifference({
//       difference: 1000 * 60 * 60 * 24 * lagDays,
//       leftField: 'system:time_start', 
//       rightField: 'system:time_start'
//     }), 
//     ee.Filter.greaterThan({
//       leftField: 'system:time_start', 
//       rightField: 'system:time_start'
//   }));
  
//   return ee.Join.saveAll({
//     matchesKey: 'images',
//     measureKey: 'delta_t',
//     ordering: 'system:time_start', 
//     ascending: false, // Sort reverse chronologically
//   }).apply({
//     primary: leftCollection, 
//     secondary: rightCollection, 
//     condition: filter
//   });
// };

// // Create a merge function
// var merge = function(image) {
//   // Function to be passed to iterate.
//   var merger = function(current, previous) {
//     return ee.Image(previous).addBands(current);
//   };
//   return ee.ImageCollection.fromImages(
// image.get('images')).iterate(merger, image);
// };


// // create the lagged ImageCollection from IMERG and S1
// var S1lag1Precip = lag(s1_preprocess_view, dailyrain, 1);     //(Make sure the left and right collections make sense!)

// // Add the precipitation images as bands.
// var S1merged1Precip = ee.ImageCollection(S1lag1Precip.map(merge));

// // Now the bands from time t and h are all in the same image.  
// // Note that the band name of ph was the same as pt.  
// // During the merging process, it gets a '_1' appended to it.  
// // Use a function to convert the merged bands to arrays with bands pt and ph, 
// // then reduce with the covariance reducer:

// var covariance = function(mergedCollection, band, lagBand) {
//   return mergedCollection.select([band, lagBand]).map(function(image) {
//     return image.toArray();
//   }).reduce(ee.Reducer.covariance(), 8);
// };

// // The diagonal elements of the variance-covariance array are variances.  
// // Function to compute correlation from the variance-covariance array:

// var correlation = function(vcArrayImage) {
//   var covariance = ee.Image(vcArrayImage).arrayGet([0, 1]);
//   var sd0 = ee.Image(vcArrayImage).arrayGet([0, 0]).sqrt();
//   var sd1 = ee.Image(vcArrayImage).arrayGet([1, 1]).sqrt();
//   return covariance.divide(sd0).divide(sd1).rename('correlation');
// };


// // Compute and display cross-covariance.
// var S1cov1Precip = covariance(S1merged1Precip, 'VH', 'precipitationCal');
// Map.addLayer(S1cov1Precip.arrayGet([0, 1]), {}, 'VH - PRECIP cov (lag = 1)');

// // Compute and display cross-correlation.
// var S1corr1Precip = correlation(S1cov1Precip);
// Map.addLayer(S1corr1Precip, {min: -0.5, max: 0.5}, 'VH - PRECIP corr (lag = 1)');