// Linear modeling of time for Sentinel-2 time series
// Estimate linear trend over time using pt = β0 + β1t + et, where e is a random error.
// Reference: https://docs.google.com/document/d/1mNIRB90jwLuASO1JYas1kuOXCLbOoy1Z4NlV1qIXM10/edit#


///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
//// PART ONE: IMPORTS AND PARAMETER DEFINITIONS   ////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////


// Geometry Imports
var Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/1_MataEscura_Hectares1"),
    Park = ee.FeatureCollection("projects/af-phenology/assets/Parks/PE_Rio_Doce"),
    plot1 = Hectares.centroid(),  // 1-ha grids are the size of our plots
    AOI = plot1.geometry();

// Define Sentinel-1 Input Parameters. 
// See https://github.com/adugnag/gee_s1_ard for more information.
/* Parameter:
        START_DATE: The earliest date to include images for (inclusive).
        END_DATE: The latest date to include images for (exclusive).
        POLARIZATION: The Sentinel-1 image polarization to select for processing.
            'VV' - selects the VV polarization.
            'VH' - selects the VH polarization.
            "VVVH' - selects both the VV and VH polarization for processing.
        ORBIT:  The orbits to include. (string: BOTH, ASCENDING or DESCENDING)
        GEOMETRY: The region to include imagery within.
                  The user can interactively draw a bounding box within the map window or define the edge coordinates.
        APPLY_BORDER_NOISE_CORRECTION: (Optional) true or false options to apply additional Border noise correction:
        APPLY_SPECKLE_FILTERING: (Optional) true or false options to apply speckle filter
        SPECKLE_FILTER: Type of speckle filtering to apply (String). If the APPLY_SPECKLE_FILTERING parameter is true then the selected speckle filter type will be used.
            'BOXCAR' - Applies a boxcar filter on each individual image in the collection
            'LEE' - Applies a Lee filter on each individual image in the collection based on [1]
            'GAMMA MAP' - Applies a Gamma maximum a-posterior speckle filter on each individual image in the collection based on [2] & [3]
            'REFINED LEE' - Applies the Refined Lee speckle filter on each individual image in the collection
                                  based on [4]
            'LEE SIGMA' - Applies the improved Lee sigma speckle filter on each individual image in the collection
                                  based on [5]
        SPECKLE_FILTER_FRAMEWORK: is the framework where filtering is applied (String). It can be 'MONO' or 'MULTI'. In the MONO case
                                  the filtering is applied to each image in the collection individually. Whereas, in the MULTI case,
                                  the Multitemporal Speckle filter is applied based on  [6] with any of the above mentioned speckle filters.
        SPECKLE_FILTER_KERNEL_SIZE: is the size of the filter spatial window applied in speckle filtering. It must be a positive odd integer.
        SPECKLE_FILTER_NR_OF_IMAGES: is the number of images to use in the multi-temporal speckle filter framework. All images are selected before the date of image to be filtered.
                                    However, if there are not enough images before it then images after the date are selected.
        TERRAIN_FLATTENING : (Optional) true or false option to apply Terrain correction based on [7] & [8]. 
        TERRAIN_FLATTENING_MODEL : model to use for radiometric terrain normalization (DIRECT, or VOLUME)
        DEM : digital elevation model (DEM) to use (as EE asset)
        TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER : additional buffer parameter for passive layover/shadow mask in meters
        FORMAT : the output format for the processed collection. this can be 'LINEAR' or 'DB'.
        CLIP_TO_ROI: (Optional) Clip the processed image to the region of interest.
        SAVE_ASSETS : (Optional) Exports the processed collection to an asset.
*/

var parameter = {//1. Data Selection
  START_DATE: "2016-01-01",
  STOP_DATE: "2022-01-01",
  POLARIZATION:'VVVH',
  ORBIT: 'DESCENDING',
  ORBIT_NUMBER: 82, //155
  GEOMETRY: Hectares.first().geometry(),
  APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION: true,
  //3.Speckle filter
  APPLY_SPECKLE_FILTERING: true,
  SPECKLE_FILTER_FRAMEWORK: 'MULTI',
  SPECKLE_FILTER: 'LEE SIGMA', 
  SPECKLE_FILTER_KERNEL_SIZE: 15,
  SPECKLE_FILTER_NR_OF_IMAGES: 5,
  //4. Radiometric terrain normalization
  APPLY_TERRAIN_FLATTENING: true,
  DEM: ee.Image('USGS/SRTMGL1_003'),
  TERRAIN_FLATTENING_MODEL: 'VOLUME',
  TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER: 100,
  //5. Output
  FORMAT : 'DB',
  CLIP_TO_ROI: false,
  SAVE_ASSETS: false,
  //6. Visualization
  VIS_BAND_RATIO: 'RVI' // or 'RVI'
}

// Constants
var AREA_NAME = 'REBIO Mata Escura, MG',
    BAND_NAME = 'VH', // parameter.VIS_BAND_RATIO
    ALL_BANDS = { VH_BAND: 'VH', VV_BAND: 'VV' },
    REDUCING_SCALE = 100 // 10m is native, but seems not to work.  1000m is fast but may throw nulls for StDev.

////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////
//// PART TWO: Define all S1 processing functions:      ////
////    A. Helpers ; B. Utilities ;                     ////
////    C. Speckle Filter ; D. Terrain Flattening ;     ////
////    E. Additional Border Noise Removal ; F. Wrapper ////
////////////////////////////////////////////////////////////
////////////////////////////////////////////////////////////


//______________//
// 2A. 'Helpers' //
//______________//

// Function to calculate median index within the given geometry
var medianIndex = function (image, geometry) {
  var stats = image.reduceRegion({
    reducer: ee.Reducer.median(),
    geometry: geometry,
    scale: 10,
    tileScale: 16
    });
  return stats;
}

// Function to select all images for the given month in a year and compute a median composite
var monthIndex = function (year, month, imageCollection) {
    var list = ee.List([]);
    var monthImages = imageCollection.filter(
     ee.Filter.calendarRange({start: year, field: 'year'})
     )
     .filter(
     ee.Filter.calendarRange({start: month, field: 'month'})
     );
  
   year = ee.Number(year).format('%d');
   month = ee.Number(month).format('%02d');
  
   var medianImage = monthImages.reduce(ee.Reducer.median());
   var name = year.cat('-').cat(month).cat('-01');

   medianImage = medianImage.set('date_range', name);
   list = ee.Algorithms.If(medianImage.bandNames().size().gt(0), 
   ee.List(list).add(medianImage), 
   list);
   return list;
}

// Function to select all images for the given month in a year and compute two median composites
 var bimonthIndex = function (year, month, imageCollection) {
  var list = ee.List([]);
  var monthImages = imageCollection.filter(
    ee.Filter.calendarRange({start: year, field: 'year'})
    )
    .filter(
    ee.Filter.calendarRange({start: month, field: 'month'})
    );
    
  var firstOfMonthImages = monthImages.filter(
    ee.Filter.calendarRange({start: 1, end: 15, field: 'day_of_month'})
    );
    
  var endOfMonthImages = monthImages.filter(
    ee.Filter.calendarRange({start: 15, end: 31, field: 'day_of_month'})
    );
  year = ee.Number(year).format('%d');
  month = ee.Number(month).format('%02d');
  
  var medianImage_1 = firstOfMonthImages.reduce(ee.Reducer.median());

  var name_1 = year.cat('-').cat(month).cat('-01');

  var medianImage_2 = endOfMonthImages.reduce(ee.Reducer.median());

  var name_2 = year.cat('-').cat(month).cat('-15');

  medianImage_1 = medianImage_1.set('date_range', name_1);
  list = ee.Algorithms.If(medianImage_1.bandNames().size().gt(0), 
  ee.List(list).add(medianImage_1), 
  list);
  medianImage_2 = medianImage_2.set('date_range', name_2);
  list = ee.Algorithms.If(medianImage_2.bandNames().size().gt(0), 
  ee.List(list).add(medianImage_2), 
  list);
  return list;
}

//function to create constant images median and st. dev as bands
var generateIndexCollection = function (indexName, imageCollection, fc) {
  
  //input can be feature or feature collection
  var feature = ee.Feature(fc.geometry());
  
  // // Function to calculate median index on an image within the geometry
  function medianIndex(image, geometry) {
    var stats = image.reduceRegion({
      reducer: ee.Reducer.median(),
      geometry: geometry,
      scale: REDUCING_SCALE,
      maxPixels:1e10
    });
    
      // set the veg index to -999 for null values
    stats = ee.List([stats.get(indexName), -999])
    .reduce(ee.Reducer.firstNonNull())

    return stats;
  }
  // Function to calculate standard deviation of index on an image within the geometry
  function sdIndex(image, geometry) {
    var stats = image.reduceRegion({
      reducer: ee.Reducer.stdDev(),
      geometry: geometry,
      scale: REDUCING_SCALE, 
      maxPixels: 1e10
    });
    
    // set the veg index to -999 for null values
    stats = ee.List([stats.get(indexName), -999])
          .reduce(ee.Reducer.firstNonNull())

    return stats;
  }
  // return a dictionary of the plot median and stdevs
  // for each image in the image collection 
  return imageCollection.map(function (image) {
      var time = image.get('system:time_start');
      var median = ee.Number(medianIndex(image, feature.geometry()));
      var median_image = ee.Image(median).double();
      var sd = ee.Number(sdIndex(image, feature.geometry()));
      var sd_image = ee.Image(sd).double();
      return ee.ImageCollection.fromImages([median_image, sd_image])
                     .toBands().set({time:time});
    });
};

/*Function to create a lagged ImageCollection containing 
//images from one collection and images in another 
//collection, lagging by one day
*/

var lag = function(leftCollection, rightCollection, lagDays) {
    var filter = ee.Filter.and(
      ee.Filter.maxDifference({
        difference: 1000 * 60 * 60 * 24 * lagDays,
        leftField: 'system:time_start', 
        rightField: 'system:time_start'
      }), 
      ee.Filter.greaterThan({
        leftField: 'system:time_start', 
        rightField: 'system:time_start'
    }));
    
    return ee.Join.saveAll({
      matchesKey: 'images',
      measureKey: 'delta_t',
      ordering: 'system:time_start', 
      ascending: false, // Sort reverse chronologically
    }).apply({
      primary: rightCollection, 
      secondary: leftCollection, 
      condition: filter
    });
};


//___________________//
// 2B. 'S1 Utilities' //
//___________________//
/*---------------------------------------------------------------------------//
// Linear to db scale 
//---------------------------------------------------------------------------*/
  
/* Convert backscatter from linear to dB. */
var lin_to_db = function(image) {
  var bandNames = image.bandNames().remove('angle');
  var db = ee.Image.constant(10).multiply(image.select(bandNames).log10()).rename(bandNames)
  return image.addBands(db, null, true)
};

/** Convert backscatter from dB to linear. */
var db_to_lin = function(image) {
  var bandNames = image.bandNames().remove('angle');
  var lin = ee.Image.constant(10).pow(image.select(bandNames).divide(10)).rename(bandNames)
  return image.addBands(lin, null, true)
};

/*Converts the linear image to db by excluding the ratio bands */
var lin_to_db2 = function(image) {
  var db = ee.Image.constant(10).multiply(image.select(['VV', 'VH']).log10()).rename(['VV', 'VH']);
  return image.addBands(db, null, true)
}

//---------------------------------------------------------------------------//
// Prepare ratio band for linear image
//---------------------------------------------------------------------------//
var add_ratio_lin = function(image){
      var ratio = image.addBands(image.select('VH').divide(image.select('VV')).rename('VHVV_ratio'));
      return ratio.set('system:time_start', image.get('system:time_start'))
  }

//---------------------------------------------------------------------------//
// Prepare alternate ratio band for image based on:
// Charbonneau, F. et al 2005. “Use of Dual Polarization and Multi-Incidence 
// SAR for Soil Permeability Mapping.” In Proceedings of the 2005 Advanced 
// Synthetic Aperture Radar (ASAR) Workshop, St-Hubert, QC, Canada, 15–17.
//---------------------------------------------------------------------------//
var add_rvi_lin = function(image){
  var rvi = image.addBands(image.expression(
    '4*a/(a+b)', {
      'a': image.select('VH'),
      'b': image.select('VV'),
    }).rename('RVI'));
  return rvi.set('system:time_start', image.get('system:time_start'));
}

//_____________________//
// 2C. 'speckle_filter' //
//_____________________//


/*---------------------------------------------------------------------------//
// Boxcar filter
//---------------------------------------------------------------------------//
/** Applies boxcar filter on every image in the collection. */
var boxcar = function(image, KERNEL_SIZE) {
  var bandNames = image.bandNames().remove('angle');
  // Define a boxcar kernel
  var kernel = ee.Kernel.square({radius: (KERNEL_SIZE/2), units: 'pixels', normalize: true});
  // Apply boxcar
  var output = image.select(bandNames).convolve(kernel).rename(bandNames);
return image.addBands(output, null, true)
};

/*---------------------------------------------------------------------------//
// Lee filter 
//---------------------------------------------------------------------------//
/** Lee Filter applied to one image. It is implemented as described in 
J. S. Lee, “Digital image enhancement and noise filtering by use of local statistics,” 
IEEE Pattern Anal. Machine Intell., vol. PAMI-2, pp. 165–168, Mar. 1980.*/
var leefilter = function(image,KERNEL_SIZE) {
      var bandNames = image.bandNames().remove('angle');
      //S1-GRD images are multilooked 5 times in range
      var enl = 5
      // Compute the speckle standard deviation
      var eta = 1.0/Math.sqrt(enl); 
      eta = ee.Image.constant(eta);

      // MMSE estimator
      // Neighbourhood mean and variance
      var oneImg = ee.Image.constant(1);

      var reducers = ee.Reducer.mean().combine({
                    reducer2: ee.Reducer.variance(),
                    sharedInputs: true
                    });
      var stats = image.select(bandNames).reduceNeighborhood({reducer: reducers,kernel: ee.Kernel.square(KERNEL_SIZE/2,'pixels'), optimization: 'window'})
      var meanBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_mean')});
      var varBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_variance')});
      
      var z_bar = stats.select(meanBand);
      var varz = stats.select(varBand);

      // Estimate weight 
      var varx = (varz.subtract(z_bar.pow(2).multiply(eta.pow(2)))).divide(oneImg.add(eta.pow(2)));
      var b = varx.divide(varz);

      //if b is negative set it to zero
      var new_b = b.where(b.lt(0), 0)
      var output = oneImg.subtract(new_b).multiply(z_bar.abs()).add(new_b.multiply(image.select(bandNames)));
      output = output.rename(bandNames);
      return image.addBands(output, null, true);
}   

/*---------------------------------------------------------------------------//
// GAMMA MAP filter 
//---------------------------------------------------------------------------//
/** Gamma Maximum a-posterior Filter applied to one image. It is implemented as described in 
Lopes A., Nezry, E., Touzi, R., and Laur, H., 1990.  Maximum A Posteriori Speckle Filtering and First Order texture Models in SAR Images.  
International  Geoscience  and  Remote  Sensing  Symposium (IGARSS).  */
var gammamap =  function(image,KERNEL_SIZE) { 
      var enl = 5;
      var bandNames = image.bandNames().remove('angle');
      //Neighbourhood stats
      var reducers = ee.Reducer.mean().combine({
                    reducer2: ee.Reducer.stdDev(),
                    sharedInputs: true
                    });
      var stats = image.select(bandNames).reduceNeighborhood({reducer: reducers,kernel: ee.Kernel.square(KERNEL_SIZE/2,'pixels'), optimization: 'window'})
      var meanBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_mean')});
      var stdDevBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_stdDev')});
      
      var z = stats.select(meanBand);
      var sigz = stats.select(stdDevBand);
      
      // local observed coefficient of variation
      var ci = sigz.divide(z);
      // noise coefficient of variation (or noise sigma)
      var cu = 1.0/Math.sqrt(enl);
      // threshold for the observed coefficient of variation
      var cmax = Math.sqrt(2.0) * cu

      cu = ee.Image.constant(cu);
      cmax = ee.Image.constant(cmax);
      var enlImg = ee.Image.constant(enl);
      var oneImg = ee.Image.constant(1);
      var twoImg = ee.Image.constant(2);

      var alpha = oneImg.add(cu.pow(2)).divide(ci.pow(2).subtract(cu.pow(2)));

      //Implements the Gamma MAP filter described in equation 11 in Lopez et al. 1990
      var q = image.select(bandNames).expression("z**2 * (z * alpha - enl - 1)**2 + 4 * alpha * enl * b() * z", {z: z, alpha: alpha,enl: enl})
      var rHat = z.multiply(alpha.subtract(enlImg).subtract(oneImg)).add(q.sqrt()).divide(twoImg.multiply(alpha));

      //if ci <= cu then its a homogenous region ->> boxcar filter
      var zHat = (z.updateMask(ci.lte(cu))).rename(bandNames)
      //if cmax > ci > cu then its a textured medium ->> apply Gamma MAP filter
      rHat = (rHat.updateMask(ci.gt(cu)).updateMask(ci.lt(cmax))).rename(bandNames)
      //if ci>=cmax then its strong signal ->> retain
      var x = image.select(bandNames).updateMask(ci.gte(cmax)).rename(bandNames)

      // Merge
      var output = ee.ImageCollection([zHat,rHat,x]).sum();
      return image.addBands(output, null, true);
}   

/*---------------------------------------------------------------------------//
// Refined Lee filter 
//---------------------------------------------------------------------------//
/** This filter is modified from the implementation by Guido Lemoine 
* Source: Lemoine et al.; https://code.earthengine.google.com/5d1ed0a0f0417f098fdfd2fa137c3d0c */
var refinedLee = function(image) {

  var bandNames = image.bandNames().remove('angle');

  var result = ee.ImageCollection(bandNames.map(function(b){
  var img = image.select([b]);
  
  // img must be linear, i.e. not in dB!
  // Set up 3x3 kernels 
  var weights3 = ee.List.repeat(ee.List.repeat(1,3),3);
  var kernel3 = ee.Kernel.fixed(3,3, weights3, 1, 1, false);

  var mean3 = img.reduceNeighborhood(ee.Reducer.mean(), kernel3);
  var variance3 = img.reduceNeighborhood(ee.Reducer.variance(), kernel3);

  // Use a sample of the 3x3 windows inside a 7x7 windows to determine gradients and directions
  var sample_weights = ee.List([[0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0], [0,1,0,1,0,1,0], [0,0,0,0,0,0,0], [0,1,0,1,0,1,0],[0,0,0,0,0,0,0]]);

  var sample_kernel = ee.Kernel.fixed(7,7, sample_weights, 3,3, false);

  // Calculate mean and variance for the sampled windows and store as 9 bands
  var sample_mean = mean3.neighborhoodToBands(sample_kernel); 
  var sample_var = variance3.neighborhoodToBands(sample_kernel);

  // Determine the 4 gradients for the sampled windows
  var gradients = sample_mean.select(1).subtract(sample_mean.select(7)).abs();
  gradients = gradients.addBands(sample_mean.select(6).subtract(sample_mean.select(2)).abs());
  gradients = gradients.addBands(sample_mean.select(3).subtract(sample_mean.select(5)).abs());
  gradients = gradients.addBands(sample_mean.select(0).subtract(sample_mean.select(8)).abs());

  // And find the maximum gradient amongst gradient bands
  var max_gradient = gradients.reduce(ee.Reducer.max());

  // Create a mask for band pixels that are the maximum gradient
  var gradmask = gradients.eq(max_gradient);

  // duplicate gradmask bands: each gradient represents 2 directions
  gradmask = gradmask.addBands(gradmask);

  // Determine the 8 directions
  var directions = sample_mean.select(1).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(7))).multiply(1);
  directions = directions.addBands(sample_mean.select(6).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(2))).multiply(2));
  directions = directions.addBands(sample_mean.select(3).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(5))).multiply(3));
  directions = directions.addBands(sample_mean.select(0).subtract(sample_mean.select(4)).gt(sample_mean.select(4).subtract(sample_mean.select(8))).multiply(4));
  // The next 4 are the not() of the previous 4
  directions = directions.addBands(directions.select(0).not().multiply(5));
  directions = directions.addBands(directions.select(1).not().multiply(6));
  directions = directions.addBands(directions.select(2).not().multiply(7));
  directions = directions.addBands(directions.select(3).not().multiply(8));

  // Mask all values that are not 1-8
  directions = directions.updateMask(gradmask);

  // "collapse" the stack into a singe band image (due to masking, each pixel has just one value (1-8) in it's directional band, and is otherwise masked)
  directions = directions.reduce(ee.Reducer.sum());  

  //var pal = ['ffffff','ff0000','ffff00', '00ff00', '00ffff', '0000ff', 'ff00ff', '000000'];
  //Map.addLayer(directions.reduce(ee.Reducer.sum()), {min:1, max:8, palette: pal}, 'Directions', false);

  var sample_stats = sample_var.divide(sample_mean.multiply(sample_mean));

  // Calculate localNoiseVariance
  var sigmaV = sample_stats.toArray().arraySort().arraySlice(0,0,5).arrayReduce(ee.Reducer.mean(), [0]);

  // Set up the 7*7 kernels for directional statistics
  var rect_weights = ee.List.repeat(ee.List.repeat(0,7),3).cat(ee.List.repeat(ee.List.repeat(1,7),4));

  var diag_weights = ee.List([[1,0,0,0,0,0,0], [1,1,0,0,0,0,0], [1,1,1,0,0,0,0], 
    [1,1,1,1,0,0,0], [1,1,1,1,1,0,0], [1,1,1,1,1,1,0], [1,1,1,1,1,1,1]]);

  var rect_kernel = ee.Kernel.fixed(7,7, rect_weights, 3, 3, false);
  var diag_kernel = ee.Kernel.fixed(7,7, diag_weights, 3, 3, false);

  // Create stacks for mean and variance using the original kernels. Mask with relevant direction.
  var dir_mean = img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel).updateMask(directions.eq(1));
  var dir_var = img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel).updateMask(directions.eq(1));

  dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel).updateMask(directions.eq(2)));
  dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel).updateMask(directions.eq(2)));

  // and add the bands for rotated kernels
  for (var i=1; i<4; i++) {
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), rect_kernel.rotate(i)).updateMask(directions.eq(2*i+1)));
    dir_mean = dir_mean.addBands(img.reduceNeighborhood(ee.Reducer.mean(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
    dir_var = dir_var.addBands(img.reduceNeighborhood(ee.Reducer.variance(), diag_kernel.rotate(i)).updateMask(directions.eq(2*i+2)));
  }

  // "collapse" the stack into a single band image (due to masking, each pixel has just one value in it's directional band, and is otherwise masked)
  dir_mean = dir_mean.reduce(ee.Reducer.sum());
  dir_var = dir_var.reduce(ee.Reducer.sum());

  // A finally generate the filtered value
  var varX = dir_var.subtract(dir_mean.multiply(dir_mean).multiply(sigmaV)).divide(sigmaV.add(1.0));

  var b = varX.divide(dir_var);

  return dir_mean.add(b.multiply(img.subtract(dir_mean)))
    .arrayProject([0])
    // Get a multi-band image bands.
    .arrayFlatten([['sum']])
    .float();
})).toBands().rename(bandNames).copyProperties(image);
return image.addBands(result, null, true) 
} 

/*---------------------------------------------------------------------------//
// Improved Lee Sigma filter 
//---------------------------------------------------------------------------//
/** Implements the improved lee sigma filter to one image. 
It is implemented as described in, Lee, J.-S.; Wen, J.-H.; Ainsworth, T.L.; Chen, K.-S.; Chen, A.J. Improved sigma filter for speckle filtering of SAR imagery. 
IEEE Trans. Geosci. Remote Sens. 2009, 47, 202–213. */
var leesigma = function(image,KERNEL_SIZE) {
      //parameters
      var Tk = ee.Image.constant(7); //number of bright pixels in a 3x3 window
      var sigma = 0.9;
      var enl = 4;
      var target_kernel = 3;
      var bandNames = image.bandNames().remove('angle');

      //compute the 98 percentile intensity 
      var z98 = image.select(bandNames).reduceRegion({
              reducer: ee.Reducer.percentile([98]),
              geometry: image.geometry(),
              scale:10,
              maxPixels:1e13
          }).toImage();
          
      //select the strong scatterers to retain
      var brightPixel = image.select(bandNames).gte(z98);
      var K = brightPixel.reduceNeighborhood({reducer: ee.Reducer.countDistinctNonNull()
                         ,kernel: ee.Kernel.square((target_kernel/2),'pixels')}); 
      var retainPixel = K.gte(Tk);


      //compute the a-priori mean within a 3x3 local window
      //original noise standard deviation
      var eta = 1.0/Math.sqrt(enl);
      eta = ee.Image.constant(eta);
      //MMSE applied to estimate the a-priori mean
      var reducers = ee.Reducer.mean().combine({
                    reducer2: ee.Reducer.variance(),
                    sharedInputs: true
                    });
      var stats = image.select(bandNames).reduceNeighborhood({reducer: reducers,kernel: ee.Kernel.square(target_kernel/2,'pixels'), optimization: 'window'})
      var meanBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_mean')});
      var varBand = bandNames.map(function(bandName){return ee.String(bandName).cat('_variance')});
      var z_bar = stats.select(meanBand);
      var varz = stats.select(varBand);
      
      var oneImg = ee.Image.constant(1);
      var varx = (varz.subtract(z_bar.abs().pow(2).multiply(eta.pow(2)))).divide(oneImg.add(eta.pow(2)));
      var b = varx.divide(varz);
      var xTilde = oneImg.subtract(b).multiply(z_bar.abs()).add(b.multiply(image.select(bandNames)));

      //step 3: compute the sigma range
      // Lookup table (J.S.Lee et al 2009) for range and eta values for intensity (only 4 look is shown here)
      var LUT = ee.Dictionary({0.5: ee.Dictionary({'I1': 0.694,'I2': 1.385,'eta': 0.1921}),
                               0.6: ee.Dictionary({'I1': 0.630,'I2': 1.495,'eta': 0.2348}),
                               0.7: ee.Dictionary({'I1': 0.560,'I2': 1.627,'eta': 0.2825}),
                               0.8: ee.Dictionary({'I1': 0.480,'I2': 1.804,'eta': 0.3354}),
                               0.9: ee.Dictionary({'I1': 0.378,'I2': 2.094,'eta': 0.3991}),
                               0.95: ee.Dictionary({'I1': 0.302,'I2': 2.360,'eta': 0.4391})});

      // extract data from lookup
      var sigmaImage = ee.Dictionary(LUT.get(String(sigma))).toImage();
      var I1 = sigmaImage.select('I1');
      var I2 = sigmaImage.select('I2');
      //new speckle sigma
      var nEta = sigmaImage.select('eta');
      //establish the sigma ranges
      I1 = I1.multiply(xTilde);
      I2 = I2.multiply(xTilde);

      //step 3: apply the minimum mean square error (MMSE) filter for pixels in the sigma range
      // MMSE estimator
      var mask = image.select(bandNames).gte(I1).or(image.select(bandNames).lte(I2));
      var z = image.select(bandNames).updateMask(mask);

      stats = z.reduceNeighborhood({reducer: reducers,kernel: ee.Kernel.square(KERNEL_SIZE/2,'pixels'), optimization: 'window'})

      z_bar = stats.select(meanBand);
      varz = stats.select(varBand);
      
      varx = (varz.subtract(z_bar.abs().pow(2).multiply(nEta.pow(2)))).divide(oneImg.add(nEta.pow(2)));
      b = varx.divide(varz);
      //if b is negative set it to zero
      var new_b = b.where(b.lt(0), 0);
      var xHat = oneImg.subtract(new_b).multiply(z_bar.abs()).add(new_b.multiply(z));

      // remove the applied masks and merge the retained pixels and the filtered pixels
      xHat = image.select(bandNames).updateMask(retainPixel).unmask(xHat);
      var output = ee.Image(xHat).rename(bandNames);
return image.addBands(output, null, true);
} 

/*---------------------------------------------------------------------------//
// 4. Mono-temporal speckle filter 
//---------------------------------------------------------------------------//

/** Mono-temporal speckle Filter   */
var MonoTemporal_Filter = function(coll,KERNEL_SIZE, SPECKLE_FILTER) {

var _filter = function(image) {
  
    if (SPECKLE_FILTER=='BOXCAR'){
    var _filtered = boxcar(image, KERNEL_SIZE);
  } else if (SPECKLE_FILTER=='LEE'){
      _filtered = leefilter(image, KERNEL_SIZE);
  } else if (SPECKLE_FILTER=='GAMMA MAP'){
      _filtered = gammamap(image, KERNEL_SIZE);
  } else if (SPECKLE_FILTER=='REFINED LEE'){
      _filtered = refinedLee(image);
  } else if (SPECKLE_FILTER=='LEE SIGMA'){
      _filtered = leesigma(image, KERNEL_SIZE);}
return _filtered;
}
return coll.map(_filter);
}

//---------------------------------------------------------------------------//
// 2C. Multi-temporal speckle filter
//---------------------------------------------------------------------------//
/* The following Multi-temporal speckle filters are implemented as described in
S. Quegan and J. J. Yu, “Filtering of multichannel SAR images,” 
IEEE Trans Geosci. Remote Sensing, vol. 39, Nov. 2001.*/

/** Multi-temporal boxcar Filter.  */
var MultiTemporal_Filter = function(coll,KERNEL_SIZE, SPECKLE_FILTER,NR_OF_IMAGES) {

var Quegan = function(image) {

  /* this function will filter the collection used for the multi-temporal part
   it takes care of:
      - same image geometry (i.e relative orbit)
      - full overlap of image
      - amount of images taken for filtering 
          -- all before
         -- if not enough, images taken after the image to filter are added */
         
  var setresample = function (image){
      return image.resample();
  };
  
  var get_filtered_collection = function (image){
    
    
    // filter collection over are and by relative orbit
    var s1_coll = ee.ImageCollection('COPERNICUS/S1_GRD_FLOAT')
              .filterBounds(image.geometry())
              .filter(ee.Filter.eq('instrumentMode', 'IW'))
              .filter(ee.Filter.listContains('transmitterReceiverPolarisation', ee.List(image.get('transmitterReceiverPolarisation')).get(-1)))
              // we need to get this from the image
              //.filter(ee.Filter.and(ee.Filter.eq('transmitterReceiverPolarisation', 'VH'),ee.Filter.eq('transmitterReceiverPolarisation', 'VH')) )
              // we filter for both because of potential change in orbit number around the Equator
              .filter(ee.Filter.or(
                  ee.Filter.eq('relativeOrbitNumber_stop', image.get('relativeOrbitNumber_stop')),
                  ee.Filter.eq('relativeOrbitNumber_stop', image.get('relativeOrbitNumber_start'))
              )).map(setresample)
    //s1_coll = s1_coll.select(image.bandNames())
    // a function that takes the image and checks for the overlap
    var check_overlap = function(_image){
        // get all S1 frames from this date intersecting with the image bounds
        var s1 = s1_coll.filterDate(_image.date(), _image.date().advance(1, 'day'))
        // intersect those images with the image to filter
        var intersect = image.geometry().intersection(s1.geometry().dissolve(), 10)
        // check if intersect is sufficient
        var valid_date = ee.Algorithms.If(
          intersect.area(10).divide(image.geometry().area(10)).gt(0.95),
          _image.date().format('YYYY-MM-dd')
        )
        return ee.Feature(null, {'date': valid_date})
    }
    
    
    // this function will pick up the acq dates for fully overlapping acquisitions before the image acquistion
    var dates_before = s1_coll.filterDate('2014-01-01', image.date().advance(1, 'day'))
      .sort('system:time_start', false).limit(5*NR_OF_IMAGES)
      // we check for overlap and sort out partly overlping acquisitions
      .map(check_overlap).distinct('date').aggregate_array('date');
  
    // if the images before are not enough, we add images from after the image acquisition 
    // this will only be the case at the beginning of S1 mission
    var dates = ee.List(
      ee.Algorithms.If(
        dates_before.size().gte(NR_OF_IMAGES),
        dates_before.slice(0, NR_OF_IMAGES),
        s1_coll
          .filterDate(image.date(), '2100-01-01')
          .sort('system:time_start', true).limit(5*NR_OF_IMAGES)
          .map(check_overlap)
          .distinct('date')
          .aggregate_array('date')
          .cat(dates_before).distinct().sort().slice(0, NR_OF_IMAGES)
      )
    )
  
    // now we re-filter the collection to get the right acquisitions for multi-temporal filtering
    return ee.ImageCollection(dates.map(function(date){
      return s1_coll.filterDate(date, ee.Date(date).advance(1,'day')).toList(s1_coll.size())
    }).flatten())
    
  }
        

// we get our dedicated image collection for that image
var s1 = get_filtered_collection(image)

var bands = image.bandNames().remove('angle');
s1 = s1.select(bands)
var meanBands = bands.map(function(bandName){return ee.String(bandName).cat('_mean')});
var ratioBands = bands.map(function(bandName){return ee.String(bandName).cat('_ratio')});
var count_img = s1.reduce(ee.Reducer.count());
//estimate means and ratios
var inner = function(image){
  if (SPECKLE_FILTER=='BOXCAR'){
    var _filtered = boxcar(image, KERNEL_SIZE).select(bands).rename(meanBands); }
  else if (SPECKLE_FILTER=='LEE'){
    _filtered = leefilter(image, KERNEL_SIZE).select(bands).rename(meanBands);}
  else if (SPECKLE_FILTER=='GAMMA MAP'){
    _filtered = gammamap(image, KERNEL_SIZE).select(bands).rename(meanBands);} 
  else if (SPECKLE_FILTER=='REFINED LEE'){
    _filtered = refinedLee(image).select(bands).rename(meanBands);} 
  else if (SPECKLE_FILTER=='LEE SIGMA'){
    _filtered = leesigma(image, KERNEL_SIZE).select(bands).rename(meanBands);}
 
  var _ratio = image.select(bands).divide(_filtered).rename(ratioBands); 
return _filtered.addBands(_ratio);
}
//perform Quegans filter
var isum = s1.map(inner).select(ratioBands).reduce(ee.Reducer.sum());
var filter = inner(image).select(meanBands);
var divide = filter.divide(count_img);
var output = divide.multiply(isum).rename(bands);

return image.addBands(output, null, true)
}
return coll.map(Quegan);
};

//_________________________//
// 2D. 'terrain_flattening' //
//_________________________//

/*---------------------------------------------------------------------------//
// Terrain Flattening
//---------------------------------------------------------------------------//
// Vollrath, A., Mullissa, A., & Reiche, J. (2020). Angular-Based Radiometric Slope Correction for Sentinel-1 on Google Earth Engine. 
Remote Sensing, 12(11), [1867]. https://doi.org/10.3390/rs12111867
*/ 
var slope_correction = function(collection, TERRAIN_FLATTENING_MODEL, 
  DEM,
  TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER) {

var ninetyRad = ee.Image.constant(90).multiply(Math.PI/180);

var _volumetric_model_SCF = function(theta_iRad, alpha_rRad) {
// Volume model
var nominator = (ninetyRad.subtract(theta_iRad).add(alpha_rRad)).tan();
var denominator = (ninetyRad.subtract(theta_iRad)).tan();
return nominator.divide(denominator);
}

var _direct_model_SCF = function(theta_iRad, alpha_rRad, alpha_azRad) {
// Surface model
var nominator = (ninetyRad.subtract(theta_iRad)).cos();
var denominator = alpha_azRad.cos()
.multiply((ninetyRad.subtract(theta_iRad).add(alpha_rRad)).cos());
return nominator.divide(denominator);
}

var _erode = function(image, distance)  {
// buffer function (thanks Noel)
var d = (image.not().unmask(1)
.fastDistanceTransform(30).sqrt()
.multiply(ee.Image.pixelArea().sqrt()));

return image.updateMask(d.gt(distance));
}

var _masking = function(alpha_rRad, theta_iRad, buffer){
// calculate masks
// layover, where slope > radar viewing angle
var layover = alpha_rRad.lt(theta_iRad).rename('layover');
// shadow
var shadow = alpha_rRad.gt(ee.Image.constant(-1).multiply(ninetyRad.subtract(theta_iRad))).rename('shadow');
// combine layover and shadow
var mask = layover.and(shadow);
// add buffer to final mask
if (buffer > 0)
mask = _erode(mask, buffer);
return mask.rename('no_data_mask');
}

var _correct = function(image) {
var bandNames = image.bandNames();
// get the image geometry and projection
var geom = image.geometry()
var proj = image.select(1).projection()

//var elevation = DEM.reproject(proj).clip(geom);

var elevation = DEM.resample('bilinear').reproject({crs:proj, scale:10}).clip(geom)

// calculate the look direction
var heading = (ee.Terrain.aspect(image.select('angle'))
.reduceRegion(ee.Reducer.mean(),image.geometry(),1000)
.get('aspect'))

heading = ee.Algorithms.If(
ee.Number(heading).gt(180),
ee.Number(heading).subtract(360),
ee.Number(heading)
)

// the numbering follows the article chapters
// 2.1.1 Radar geometry 
var theta_iRad = image.select('angle').multiply(Math.PI/180)
var phi_iRad = ee.Image.constant(heading).multiply(Math.PI/180)

// 2.1.2 Terrain geometry
//slope 
var alpha_sRad = ee.Terrain.slope(elevation).select('slope').multiply(Math.PI / 180)

// aspect (-180 to 180)
var aspect = ee.Terrain.aspect(elevation).select('aspect').clip(geom)

// we need to subtract 360 degree from all values above 180 degree
var aspect_minus = aspect
.updateMask(aspect.gt(180))
.subtract(360)

// we fill the aspect layer with the subtracted values from aspect_minus
var phi_sRad = aspect
.updateMask(aspect.lte(180))
.unmask() 
.add(aspect_minus.unmask()) //add the minus values
.multiply(-1)   // make aspect uphill
.multiply(Math.PI / 180) // make it rad

// we get the height, for export 
//var height = DEM.reproject(proj).clip(geom)

// 2.1.3 Model geometry
//reduce to 3 angle
var phi_rRad = phi_iRad.subtract(phi_sRad)

// slope steepness in range (eq. 2)
var alpha_rRad = (alpha_sRad.tan().multiply(phi_rRad.cos())).atan()

// slope steepness in azimuth (eq 3)
var alpha_azRad = (alpha_sRad.tan().multiply(phi_rRad.sin())).atan()

// local incidence angle (eq. 4)
var theta_liaRad = (alpha_azRad.cos().multiply((theta_iRad.subtract(alpha_rRad)).cos())).acos()
var theta_liaDeg = theta_liaRad.multiply(180/Math.PI)

// 2.2 
// Gamma_nought
var gamma0 = image.divide(theta_iRad.cos())

if (TERRAIN_FLATTENING_MODEL == 'VOLUME') {
// Volumetric Model
var scf = _volumetric_model_SCF(theta_iRad, alpha_rRad)
}

if (TERRAIN_FLATTENING_MODEL == 'DIRECT') {
var scf = _direct_model_SCF(theta_iRad, alpha_rRad, alpha_azRad)
}
// apply model for Gamm0
var gamma0_flat = gamma0.multiply(scf)

// get Layover/Shadow mask
var mask = _masking(alpha_rRad, theta_iRad, TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER);

var output = gamma0_flat.mask(mask).rename(bandNames).copyProperties(image);

output = ee.Image(output).addBands(image.select('angle'),null,true);

return output.set('system:time_start', image.get('system:time_start')); 
}   
return collection.map(_correct)
}

//______________________________//
// 2E. 'border_noise_correction' //
//______________________________//

/* File: border_noise_correction.js
Version: v1.1
Date: 2021-03-11
Authors: Adopted from Hird et al. 2017 Remote Sensing (supplementary material): http://www.mdpi.com/2072-4292/9/12/1315)
Description: This script applied additional border noise correction */
/*---------------------------------------------------------------------------//
// Additional Border Noise Removal
//---------------------------------------------------------------------------*/
/** (mask out angles >= 45.23993) */
var maskAngLT452 = function(image) {
 var ang = image.select(['angle']);
 return image.updateMask(ang.lt(45.23993)).set('system:time_start', image.get('system:time_start'));
};

/** Function to mask out edges of images using angle.
 * (mask out angles <= 30.63993) */
var maskAngGT30 = function(image) {
 var ang = image.select(['angle']);
 return image.updateMask(ang.gt(30.63993)).set('system:time_start', image.get('system:time_start'));
};

/** Remove edges.
 * Source: Andreas Vollrath */
var maskEdge = function(image) {
  var mask = image.select(0).unitScale(-25, 5).multiply(255).toByte()//.connectedComponents(ee.Kernel.rectangle(1,1), 100);
  return image.updateMask(mask.select(0)).set('system:time_start', image.get('system:time_start'));  
};

/** Mask edges. This function requires that the input image has one VH or VV band, and an 'angle' bands.  */
var f_mask_edges = function(image) {
  var db_img = lin_to_db(image)
  var output = maskAngGT30(db_img);
  output = maskAngLT452(output);
  //output = maskEdge(output);
  output = db_to_lin(output);
  return output.set('system:time_start', image.get('system:time_start'));
};

//_________________//
// 2F. 'S1 Wrapper' //
//_________________//

/*---------------------------------------------------------------------------//
// ALL PREPROCESSING
//---------------------------------------------------------------------------*/
var s1_preproc = function(params) {
  
  /************************  
   * 0. CHECK PARAMETERS  
  ************************/
     if (params.ORBIT === undefined) params.ORBIT = 'BOTH';
     if (params.SPECKLE_FILTER === undefined) params.SPECKLE_FILTER = "GAMMA MAP";
     if (params.SPECKLE_FILTER_KERNEL_SIZE === undefined) params.SPECKLE_FILTER_KERNEL_SIZE = 7;
     if (params.TERRAIN_FLATTENING_MODEL === undefined) params.TERRAIN_FLATTENING_MODEL = 'VOLUME';
     if (params.TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER === undefined) params.TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER = 0;
     if (params.FORMAT === undefined) params.FORMAT = 'DB';
     if (params.DEM === undefined) params.DEM = ee.Image('USGS/SRTMGL1_003');
     if (params.POLARIZATION === undefined) params.POLARIZATION = 'VVVH';
     if (params.APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION === undefined) params.APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION = true;
     if (params.APPLY_TERRAIN_FLATTENING === undefined) params.APPLY_TERRAIN_FLATTTENING = true;
     if (params.APPLY_SPECKLE_FILTERING === undefined) params.APPLY_SPECKLE_FILTERING = true; 
     if (params.SPECKLE_FILTER_FRAMEWORK === undefined) params.SPECKLE_FILTER_FRAMEWORK = 'MULTI';
     
     function notContains(list, value) {return list.indexOf(value) == -1;}
     
     var orbit_required = ['ASCENDING', 'DESCENDING', 'BOTH']
     if (notContains(orbit_required, params.ORBIT)) {
          throw new Error("Parameter ORBIT not correctly defined")
     } 
     
     var pol_required = ['VV', 'VH', 'VVVH']
     if (notContains(pol_required, params.POLARIZATION)) {
          throw new Error("Parameter POLARIZATION not correctly defined")
     } 
     
     var model_required = ['DIRECT', 'VOLUME']
     if (notContains(model_required, params.TERRAIN_FLATTENING_MODEL)) {
          throw new Error("Parameter TERRAIN_FLATTENING_MODEL not correctly defined")
     } 
     
     var format_required = ['LINEAR', 'DB']
     if (notContains(format_required, params.FORMAT)) {
          throw new Error("Parameter FORMAT not correctly defined")
     } 
     
     var frame_required = ['MONO', 'MULTI']
     if (notContains(frame_required, params.SPECKLE_FILTER_FRAMEWORK)) {
          throw new Error("Parameter SPECKLE_FILTER_FRAMEWORK not correctly defined")
     } 
     
     var sfilter_required = ['BOXCAR', 'LEE', 'GAMMA MAP'
                , 'REFINED LEE', 'LEE SIGMA']
     if (notContains(sfilter_required, params.SPECKLE_FILTER)) {
          throw new Error("Parameter SPECKLE_FILTER not correctly defined")
     } 
   
     if (params.TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER < 0) {
     throw new Error("The TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER should be GREATER or EQUAL to 0")}
   
     if (params.SPECKLE_FILTER_KERNEL_SIZE <= 0) {
     throw new Error("The SPECKLE_FILTER_KERNEL_SIZE should be a positive integer")}   
  
  /************************  
   * 1. Data Selection
  ************************/ 
  
  // Select S1 GRD ImageCollection
var s1 = ee.ImageCollection('COPERNICUS/S1_GRD_FLOAT')
      .filter(ee.Filter.eq('instrumentMode', 'IW'))
      .filter(ee.Filter.eq('resolution_meters', 10))
      .filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VH'))
      //.filter(ee.Filter.listContains('transmitterReceiverPolarisation', 'VV'))
      .filterDate(params.START_DATE, params.STOP_DATE)
      .filterBounds(params.GEOMETRY)
//      .filter(ee.Filter.calendarRange(params.DAY_START,params.DAY_END,'day_of_month'));
  
  //select orbit
  if (params.ORBIT !== 'BOTH'){s1 = s1.filter(ee.Filter.eq('orbitProperties_pass', params.ORBIT))}
  
  //select polarization
  if (params.POLARIZATION=='VV') { s1 = s1.select(['VV','angle'])}
  else if (params.POLARIZATION=='VH') {s1 = s1.select(['VH','angle'])}
  else if (params.POLARIZATION=='VHVV') {s1 = s1.select(['VV', 'VH', 'angle'])}
  
  print('Number of images in S1 collection: ', s1.size());
  
  /************************************  
   * 2. Additional Border Noise Correction  
  ************************************/
  
  if (params.APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION) {
    var s1_1 = s1.map(f_mask_edges) 
    print("border noise done") //print('ADDITIONAL BORDER NOISE CORRECTION COMPLETED') 
    }
  else {s1_1 = s1}


  /*************************  
   * 3. Speckle Filtering  
  *************************/
 if (params.APPLY_SPECKLE_FILTERING) {
    if (params.SPECKLE_FILTER_FRAMEWORK == 'MONO') {
        s1_1 = ee.ImageCollection(MonoTemporal_Filter(s1_1, params.SPECKLE_FILTER_KERNEL_SIZE, params.SPECKLE_FILTER ))
        print("speckle filter done") //print('MONO-TEMPORAL SPECKLE FILTERING COMPLETED') 
  }
    else {
        s1_1 = ee.ImageCollection(MultiTemporal_Filter(s1_1, params.SPECKLE_FILTER_KERNEL_SIZE, params.SPECKLE_FILTER,params.SPECKLE_FILTER_NR_OF_IMAGES ));
        print("speckle filter done") //print('MULTI-TEMPORAL SPECKLE FILTERING COMPLETED') 
  }    
 }  
 
   /***************************************   
   * 4. Radiometric Terrain Normalization 
  ****************************************/
  
  if (params.APPLY_TERRAIN_FLATTENING) {
      s1_1 = ee.ImageCollection(slope_correction(s1_1, params.TERRAIN_FLATTENING_MODEL, params.DEM, params.TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER)); 
      print("terrain norm. done") // print('RADIOMETRIC TERRAIN NORMALIZATION COMPLETED')
  }
  
      //Clip to roi (input)
  if (params.CLIP_TO_ROI) {s1 = s1.map(function(image) {
              return image.clip(params.GEOMETRY)})}
  
        //Clip to roi (processed)
  if (params.CLIP_TO_ROI) {s1_1 = s1_1.map(function(image) {
              return image.clip(params.GEOMETRY)})}
  
  return [s1, s1_1]
};
  
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////
//// PART THREE: BUILD THE SENTINAL-1 COLLECTION   ////
///////////////////////////////////////////////////////
///////////////////////////////////////////////////////

//___________________//
// 3A. Preprocessing //
//___________________//

//Preprocess the S1 collection
var s1_preprocess = s1_preproc(parameter);
var s1 = s1_preprocess[0];
s1_preprocess = s1_preprocess[1];


//_____________//
// 3B. Filters //
//_____________//

// Filter to consistent orbit number
s1_preprocess = s1_preprocess.filter(ee.Filter.eq('relativeOrbitNumber_start', 
                parameter.ORBIT_NUMBER));
print("ARD processed S1 collection - single orbit", s1_preprocess);

//// Temporal Filter.

//// Considering the temporal variability in the median backscatter values a temporal smoothing
//// may be warrented.  Compute a collection of bimonthly or monthly images averages of 
//// backscatter values that a occur across all the images that occur in a given month.

// // Create Bimonthly-index dictionaries, set them
// // for each year add on to it

// var START_YEAR = ee.Date(parameter.START_DATE).get('year');
// var STOP_YEAR = ee.Date(parameter.STOP_DATE).advance(-1, 'year').get('year');
// var MONTHS = ee.List.sequence(1, 12);
// var YEARS = ee.List.sequence(START_YEAR,STOP_YEAR);

// // Returns a collection of bimonthly medians.
// // Includes property 'date_range' which indicates the start date

// var bimonthlyImages = ee.ImageCollection(YEARS.map(function (year) { 
//   return MONTHS.map(function (month) {
//     return bimonthIndex(year, month, {}, s1_preprocess);
//   })})
//   .flatten());

// print("ARD processed S1 Bi-Monthly Images - Input Collection", bimonthlyImages);

// // Returns a collection of monthly medians.
// // Includes property 'date_range' which indicates the start date

// var monthlyImages = ee.ImageCollection(YEARS.map(function (year) { 
//   return MONTHS.map(function (month) {
//     return monthIndex(year, month, {}, s1_preprocess);
//   })})
//   .flatten());

// print("ARD processed S1 Monthly Images - Input Collection", monthlyImages);


// Meteorological Filter. 
// Create a merged S1 Collection with a precipitation (IMERG) property which is lagged
// by one day, the theory being that wet vegetation (lasting up to one day)
// gives anomalous backscatter signals. The merged collection can then filtered for
// S1 images whose lagged precip property values are anomalously high.

var START_DATE = parameter.START_DATE,
    END_DATE = parameter.STOP_DATE,
    numberOfDays = ee.Date(END_DATE).difference(ee.Date(START_DATE), 'days');

var dailyraincol = ee.ImageCollection(
  ee.List.sequence(0, numberOfDays.subtract(1))
    .map(function (dayOffset) {
      var start = ee.Date(START_DATE).advance(dayOffset, 'days')
      var end = start.advance(1, 'days')
      return ee.ImageCollection('NASA/GPM_L3/IMERG_V06')
      .filterDate(start, end)
      .max()
      .set('system:time_start', start.millis())
    })
)

dailyraincol = dailyraincol.select('precipitationCal')


///  ****** ERROR HERE ******
// Something is wrong in this section which causes the 
// wrong precip value to be written to the property.  
// seems to be the same value for every image in the 
// time series..

//function to remove masked images
var filter_masked = function(img) {
  // unmask each image in the collection
  var unmasked = img.unmask(-999).eq(-999);
  // reduce histogram on each image and set the keys as properties (key '1' will be masked pixels)
  var rR = unmasked.reduceRegion({
                              reducer: ee.Reducer.frequencyHistogram(),
                              geometry: Hectares.geometry(),
                              scale: REDUCING_SCALE,
                              bestEffort: true
                              });
  var newProperty = ee.Dictionary(rR.get('precipitationCal'));
  return img.set(newProperty)
}


//mask out low precipitation values
var highcoll = dailyraincol.map(function (img) {
                var mask = img.gte(1);
                return img.updateMask(mask);
                })
//apply the mask                

var first = highcoll.first()
var unmaskd = first.unmask(-999).eq(-999)
var rR = unmaskd.reduceRegion({
                              reducer: ee.Reducer.frequencyHistogram(),
                              geometry: Hectares.geometry(),
                              scale: REDUCING_SCALE,
                              bestEffort: true
                              }).get('precipitationCal');
rR = ee.Dictionary(rR)                              
print(rR.get('1'))


var high_coll_unmask = highcoll.map(filter_masked)

print('High Rainfall Collection', high_coll_unmask)


//high precip collection without masked pixels
var highcolNotMasked = ee.ImageCollection(high_coll_unmask).filter(ee.Filter.notNull(['1']).not())

highcolNotMasked = highcolNotMasked.map(function(image) {
                    var precipdict = ee.Dictionary(image.get('precipitationCal'))
                    return image.set('precipitationCal', precipdict.get('1'))
})


//clip to the parkboundaries
highcolNotMasked = highcolNotMasked.map(function(image){return image.clip(Park.geometry())})  

print('High Rainfall Collection', highcolNotMasked)

Map.centerObject(Park, 12);


// // Visualize the IMERG data
// var palette = [	  '000096','0064ff', '00b4ff', '33db80', '9beb4a',	  'ffeb00', 'ffb300', 'ff6400', 'eb1e00', 'af0000'	];
// var highprecipVis = {opacity: 0.5, min: 0.0, max: 20.0, palette: palette};	
// Map.addLayer(highcolNotMasked.first(), highprecipVis, 'High Precipitation Collection (mm/Hr)');					


/* Function to create a lagged ImageCollection containing 
// images from one collection and images in another 
// collection, lagging by one day
*/

var lagfilter = ee.Filter.and(
    ee.Filter.maxDifference({
      difference: 1000 * 60 * 60 * 24 * 1,  //Filter by 1 day
      leftField: 'system:time_start', 
      rightField: 'system:time_start'
    }), 
    ee.Filter.greaterThan({
      leftField: 'system:time_start', 
      rightField: 'system:time_start'
    }));

var join = ee.Join.saveFirst({
  matchKey: 'images',
  measureKey: 'delta_t',
  ordering: 'system:time_start', 
  ascending: false,
  outer: true  //preserve all S1 images
})

// Join S1 with low rainfall dataset, lagged by one day
var S1LaggedRain = join.apply({
        primary: s1_preprocess, 
        secondary: highcolNotMasked,
        condition: lagfilter
        })
        

print("Joined S1 Collection / IMERG collection", S1LaggedRain)


// Copy precip. property
var copyProps = function (index) {
    var source = ee.Image(highcolNotMasked.toList(highcolNotMasked.size()).get(index))
    var dest = ee.Image(S1LaggedRain.toList(S1LaggedRain.size()).get(index))
    var image = ee.Image(dest.copyProperties(source))
    return image
}
var seq = ee.List.sequence(0, S1LaggedRain.size().subtract(1))
S1LaggedRain = ee.ImageCollection(seq.map(copyProps))
S1LaggedRain = S1LaggedRain.map(function(img) {
  return img.set('precipitationCal', img.get('precipitationCal'));
});

print("S1 Collection with added Precip. property", S1LaggedRain)

// Convert precip property to a band for plotting
var S1LaggedRain = S1LaggedRain.map(function (image) {
  var precipval = ee.Number(image.get('precipitationCal'))
  var precipband = ee.Image.constant(precipval).rename('precipitationCal');
  return image.addBands(precipband);
});

print("S1 Collection with added Precip. band", S1LaggedRain)


//visualize first image from the new collection
var S1LaggedRain_view = S1LaggedRain.map(add_ratio_lin).map(lin_to_db2);
var visparam = {bands: ['VH', 'VV', parameter.VIS_BAND_RATIO], min: [-16, -10, 0],max: [-9, -5, 0.6]}
Map.addLayer(S1LaggedRain_view.first(), visparam, 'S1 image with added lagged Precip band')		


// Add region of interest	Map.centerObject(Park, 10);		
var empty = ee.Image().byte();	
var parkboundary = empty.paint({featureCollection: Park, color: 1, width: 3});	
Map.addLayer(parkboundary, {palette: '00FF00'}, 'Park');	


// Display a time-series chart of sentinel-1 values with high precip values flagged

var chart = ui.Chart.image.series({
  imageCollection: S1LaggedRain_view,                          // Image collection we want to use for timeseries analysis
  region: Hectares,                                            // plot boundaries
  reducer: ee.Reducer.median(),                                // Pixel we want to use
  scale: REDUCING_SCALE,                                       // [Spatial Resolution]: 500
  xProperty: 'system:time_start'                       // Date 
})
.setOptions({
title: 'IMERG Daily Maximum Precip. Anomaly ( > 1 mm/Hr ) over ' + AREA_NAME,
legend: {position: 'none'},
series: {
    0: {targetAxisIndex: 0, type: "line", lineWidth: 1, pointSize: 0, color: "orange"},
    1: {visibleInLegend: false, type: "line", lineWidth: 0},
    2: {visibleInLegend: false, type: "line", lineWidth: 0},
    3: {targetAxisIndex: 1, type: "point", lineWidth: 0, pointSize: 2, color: "blue"}
  },
  hAxis: {title: '', format: 'YYYY-MMM-dd'},
vAxes: {
  0: {
      title: BAND_NAME + "backscatter (dB)",
      baseline: 0,
      titleTextStyle: {bold: true, color: 'orange'},
      viewWindow: { min: -15, max: -10 }
    },
  1: {
      title: "Precip. (mm/Hr)",
      baseline: 0,
      titleTextStyle: {bold: true, color: 'blue'},
      viewWindow: { min: 0 }
    }
}
});

print('IMERG Daily Maximum Precip. Anomaly ( > 1 mm/Hr ) over ' + AREA_NAME, chart);


