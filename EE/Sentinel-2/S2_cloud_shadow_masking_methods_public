// This example demonstrates the use of the
// COPERNICUS/S2_CLOUD_PROBABILITY dataset, the
// ee.Algorithms.Sentinel2.CDI() method for computing a
// cloud displacement index and directionalDistanceTransform()
// for computing cloud shadows.
//
// See a similar script for the Python API here:
// https://developers.google.com/earth-engine/tutorials/community/sentinel-2-s2cloudless
//
// Two other methods are included for comparison, including maskin by the S2 cloud-probability collection:
// https://developers.google.com/earth-engine/datasets/catalog/COPERNICUS_S2_CLOUD_PROBABILITY
// and the "Clear Sky" method:
// https://gis.stackexchange.com/questions/426571/cloud-shadow-removal-for-sentinel-2

/////////////////////////////////////////
////IMPORT COLLECTIONS///////////////////
/////////////////////////////////////////
var S2 = ee.ImageCollection("COPERNICUS/S2"),  // S2 L1C for Cloud Displacement Index (CDI) bands.
    S2c = ee.ImageCollection('COPERNICUS/S2_CLOUD_PROBABILITY'),
    S2Sr = ee.ImageCollection('COPERNICUS/S2_SR'),
    AOI = ee.Geometry.Point(-122.269, 45.701);

/////////////////////////////////////////
////CONSTANTS////////////////////////////
/////////////////////////////////////////
var start = '2018-01-01';
var end = '2022-01-01';

/////////////////////////////////////////
////FUNCTIONS////////////////////////////
/////////////////////////////////////////
  
//Define a generic join function   
var indexJoin = function (collectionA, collectionB, propertyName) {
  var joined = ee.ImageCollection(ee.Join.saveFirst(propertyName).apply({
    primary: collectionA,
    secondary: collectionB,
    condition: ee.Filter.equals({
      leftField: 'system:index',
      rightField: 'system:index'})
  }));
  // Merge the bands of the joined image.
  return joined.map(function(image) {
    return image.addBands(ee.Image(image.get(propertyName)));
  });
};

//Define a function which adds the cloud probability property to the dataset
var s2AddCloudProbability = function (s2, s2CloudProb) {
// Join S2 SR with cloud probability dataset to add cloud mask.
  var s2WithCloudProperty = ee.Join.saveFirst('cloud_mask').apply({
    primary: s2,
    secondary: s2CloudProb,
    condition:
        ee.Filter.equals({leftField: 'system:index', rightField: 'system:index'})
  });
  return ee.ImageCollection(s2WithCloudProperty);
};


/////////////////////////////////////////
////CLOUD MASKING FUNCTIONS//////////////
/////////////////////////////////////////


// Method 1: Cloud Probability masking 
var s2MaskClouds = function (s2WithCloudProbability, maxCloudProbability) {
  function maskClouds(img) {
    var clouds = ee.Image(img.get('cloud_mask')).select('probability');
    var isNotCloud = clouds.lt(maxCloudProbability);
    return img.updateMask(isNotCloud);
  }
  // The masks for the 10m bands sometimes do not exclude bad data at
  // scene edges, so we apply masks from the 20m and 60m bands as well.
  function maskEdges(s2_img) {
    return s2_img.updateMask(
        s2_img.select('B8A').mask().updateMask(s2_img.select('B9').mask()));
  }
  s2WithCloudProbability = s2WithCloudProbability.map(maskEdges);
  var s2CloudMasked = s2WithCloudProbability.map(maskClouds);
  return s2CloudMasked;
}

// Method 2: Clear Sky algorithm
var s2_clear_sky = function (image){
      var scl = image.select('SCL');
      var clear_sky_pixels = scl.eq(4).or(scl.eq(5)).or(scl.eq(6)).or(scl.eq(11));
      return image.updateMask(clear_sky_pixels);
    };
    
// Method 3: CDI masking algorithm. n.b.: 
// Linear projection of 5km may not be appropriate
var s2CDImask = function (image) {
  // Compute the cloud displacement index from the L1C bands.
  var cdi = ee.Algorithms.Sentinel2.CDI(image);
  var s2c = image.select('probability');
  var cirrus = image.select('B10').multiply(0.0001);

  // Assume low-to-mid atmospheric clouds to be pixels where probability
  // is greater than 65%, and CDI is less than -0.5. For higher atmosphere
  // cirrus clouds, assume the cirrus band is greater than 0.01.
  // The final cloud mask is one or both of these conditions.
  var isCloud = s2c.gt(65).and(cdi.lt(-0.5)).or(cirrus.gt(0.01));

  // Reproject is required to perform spatial operations at 20m scale.
  // 20m scale is for speed, and assumes clouds don't require 10m precision.
  isCloud = isCloud.focal_min(3).focal_max(16);
  isCloud = isCloud.reproject({crs: cdi.projection(), scale: 20});

  // Project shadows from clouds we found in the last step. This assumes we're working in
  // a UTM projection.
  var shadowAzimuth = ee.Number(90)
      .subtract(ee.Number(image.get('MEAN_SOLAR_AZIMUTH_ANGLE')));

  // With the following reproject, the shadows are projected 5km.
  isCloud = isCloud.directionalDistanceTransform(shadowAzimuth, 50);
  isCloud = isCloud.reproject({crs: cdi.projection(), scale: 100});

  isCloud = isCloud.select('distance').mask();
  return image.select('B2', 'B3', 'B4').updateMask(isCloud.not());
}


/////////////////////////////////////
////Build Sentinel-2 collections//////
/////////////////////////////////////

    
// S2 L1C for Cloud Displacement Index (CDI) bands.
S2 = S2.filterDate(start, end).filterBounds(AOI).
// S2Cloudless for the cloud probability band.
S2c = S2c.filterDate(start, end).filterBounds(AOI);
// S2 L2A for surface reflectance bands.
S2Sr = S2Sr.filterDate(start, end).filterBounds(AOI);


// Filter by study dates and plot bounds
var filter = ee.Filter.and(
    ee.Filter.bounds(AOI), 
    ee.Filter.date(start, end));

S2Sr = S2Sr.filter(filter)

/////////////////////////////////////
////APPLY ALGORITHMS/////////////////
/////////////////////////////////////

//Method 1, Collection 1: Cloud Probability masking

var s2WithCloudProperty = S2Sr.s2AddCloudProbability(S2c);
var s2CloudFiltered = s2WithCloudProperty.filterMetadata('CLOUDY_PIXEL_PERCENTAGE', 'less_than', 60);
var s2CloudMasked = s2CloudFiltered.s2MaskClouds(60);

//Method 2, Collection 2: Clear Sky algorithm

var s2ClearSky = S2Sr.map(s2_clear_sky)

//Method 3, Collection 3: Clear Sky algorithm
/////Join the cloud probability dataset to surface reflectance.
var withCloudProbability = S2Sr.indexJoin(S2c, 'cloud_probability');

/////Join the L1C data to get the bands needed for CDI.
var withS2L1C = withCloudProbability.indexJoin(S2, 'l1c');

/////Map the cloud masking function over the joined collection.
var CDImasked = ee.ImageCollection(withS2L1C.map(s2CDImask));


/////////////////////////////////////
////VISUALIZE////////////////////////
/////////////////////////////////////
var rgbVis = {
    min: 0.0,
    max: 3000,
    bands: ['B4', 'B3', 'B2'],
  };

var maskVis = {
	opacity:1,
	bands: ["B4","B2","B2"],
	min:200,
	max:200,
	gamma:1
  };

// // Uncomment for normal visualization
// Map.centerObject(S2Sr.first(), 11)
// Map.addLayer(S2Sr.first(), rgbVis, 'original S2 image');
// Map.addLayer(s2CloudMasked.first(), maskVis, 'Yuki s2CloudMasked algorithm S2 image', false)
// Map.addLayer(s2ClearSky.first(), maskVis, 'clear_sky algorithm S2 image', false) ;
// Map.addLayer(CDImasked.first(), maskVis, 'cloud shadow S2 image');


//splitscreen visualization

var leftMap = ui.Map();
var rightMap = ui.Map();

var S2Sr_lyr = ui.Map.Layer(S2Sr.first(), rgbVis, 'original S2 image');
var S2CloudMasked_lyr = ui.Map.Layer(s2CloudMasked.first(), maskVis, 'Yuki s2CloudMasked algorithm S2 image');
var S2ClearSky_lyr = ui.Map.Layer(s2ClearSky.first(), maskVis, 'clear_sky algorithm S2 image');
var S2CDImasked_lyr = ui.Map.Layer(CDImasked.first(), maskVis, 'cloud shadow S2 image');

// create image dictionary
var images = {
  'Method 1: Yuki s2CloudMasked algorithm': getImage(3),
  'Method 2: clear_sky algorithm': getImage(2),
  'Method 3: CDI cloud shadow': getImage(1)
};

function getImage(number) {
  number = ee.Number(number)
  var collection = ee.ImageCollection([  // collection of images
  S2Sr.first(), 
  masked.first(), 
  s2ClearSky.first(), 
  s2CloudMasked.first() 
  ]) 
  var listOfImages = collection.toList(collection.size()); // list of images
  var image = ee.Image(listOfImages.get(number)); // get individual image
  return image.visualize(maskVis); //style
}

var left_layers = leftMap.layers() ; var right_layers = rightMap.layers() ;

left_layers
.add(S2CloudMasked_lyr)
.add(S2ClearSky_lyr)
.add(S2CDImasked_lyr)

right_layers.add(S2Sr_lyr)

var splitPanel = ui.SplitPanel({
    firstPanel: leftMap,
    secondPanel: rightMap,
    orientation: 'horizontal',
    wipe: true
})

ui.root.clear()

ui.root.add(splitPanel)

var linkPanel = ui.Map.Linker([leftMap,rightMap])

leftMap.centerObject(S2Sr.first(), 10)

leftMap.setControlVisibility(false);
var leftSelector = addLayerSelector(leftMap, 0, 'top-left');

// Add info
var info = ui.Panel({
  style: {
    position: 'bottom-center',
    padding: '8px 15px'
  }
});
var info2 = ui.Label({
  value: 'Split Panels of several cloud/shadow masking methods (left) and the original Sentinel-2 image (right)',
  style: {
    fontSize: '16px',
    margin: '0 0 3px 0',
    padding: '0'
    }
});
info.add(info2);
rightMap.add(info);


// Adds a layer selection widget to the given map, to allow users to change
// which image is displayed in the associated map.
function addLayerSelector(mapToChange, defaultValue, position) {
  var label = ui.Label('Select Image Masking Method');
  // This function changes the given map to show the selected image.
  function updateMap(selection) {
    mapToChange.layers().reset()
    mapToChange.layers().set(0, ui.Map.Layer(images[selection]));
  }

  // Configure a selection dropdown to allow the user to choose between images,
  // and set the map to update when a user makes a selection.
  var select = ui.Select({items: Object.keys(images), onChange: updateMap});
  select.setValue(Object.keys(images)[defaultValue], true);

  var controlPanel =
      ui.Panel({widgets: [label, select], style: {position: position}});

  mapToChange.add(controlPanel);
}