/* Helper functions. 
 *
 * Inspired by https://medium.com/google-earth/making-it-easier-to-reuse-code-with-earth-engine-script-modules-2e93f49abb13
 */

var constants = require('users/brbell01/AF_Phenology:Constants');

//------------------------------------------------------------------------------------
//Cloud and cloud shadow masking functions

/* adds a mask to areas covered by clouds.
 * appropriate for level Sentinel-2 L1C images
 *
 * image - the image to add the cloud mask.
 * returns - an image with the cloud mask.
 */

exports.s2_level1c_cloudmask = function (image) {
  var qa = image.select('QA60');
  var cloudBitMask = 1 << 10;
  var cirrusBitMask = 1 << 11;
  var mask = qa.bitwiseAnd(cloudBitMask).eq(0).and(
             qa.bitwiseAnd(cirrusBitMask).eq(0));
  return image.updateMask(mask)
      .select("B.*")
      .copyProperties(image, ["system:time_start"]);
};

// Creates a mask using for clouds and shadows using the cloud displacement index (CDI)
exports.maskImage = function(image) {
  // Compute the cloud displacement index from the L1C bands.
  var cdi = ee.Algorithms.Sentinel2.CDI(image);
  var S2c = image.select('probability');
  var cirrus = image.select('B10').multiply(0.0001);

  /* Assume low-to-mid atmospheric clouds to be pixels where probability
  // is greater than 60%, and CDI is less than -0.1. For higher atmosphere
  // cirrus clouds, assume the cirrus band is greater than 0.01.
  // The final cloud mask is one or both of these conditions.
  */
  var isCloud = S2c.gt(60).and(cdi.lt(-0.1)).or(cirrus.gt(0.01));

  // Reproject is required to perform spatial operations at 40m scale.
  // 40m scale is for speed, and assumes clouds don't require 10m precision.
  isCloud = isCloud.focal_min(3).focal_max(16);
  isCloud = isCloud.reproject({crs: cdi.projection(), scale: 40});

  // Project shadows from clouds we found in the last step. This assumes we're working in
  // a UTM projection.
  var shadowAzimuth = ee.Number(90)
      .subtract(ee.Number(image.get('MEAN_SOLAR_AZIMUTH_ANGLE')));

  // With the following reproject, the shadows are projected 0.5km.
  isCloud = isCloud.directionalDistanceTransform(shadowAzimuth, 5);
  isCloud = isCloud.reproject({crs: cdi.projection(), scale: 100});

  isCloud = isCloud.select('distance').mask();
  return image.updateMask(isCloud.not());
}

  /* Generic join of two collections based on their 'system:index' property.
  // The propertyName parameter is the name of the property
  // that references the joined image.
  */

exports.indexJoin = function (collectionA, collectionB, propertyName) {
  var joined = ee.ImageCollection(ee.Join.saveFirst(propertyName).apply({
    primary: collectionA,
    secondary: collectionB,
    condition: ee.Filter.equals({
      leftField: 'system:index',
      rightField: 'system:index'})
  }));
  // Merge the bands of the joined image.
  return joined.map(function(image) {
    return image.addBands(ee.Image(image.get(propertyName)));
  });
};

//Join collection with cloud probability collection  
exports.s2AddCloudProbability = function (s2, s2CloudProb) {
  // Join S2 SR with cloud probability dataset to add cloud mask.
  var s2WithCloudProperty = ee.Join.saveFirst('cloud_mask').apply({
    primary: s2,
    secondary: s2CloudProb,
    condition:
        ee.Filter.equals({leftField: 'system:index', rightField: 'system:index'})
  });
  return ee.ImageCollection(s2WithCloudProperty);
};

//Apply a cloud masking function using a threshold value
exports.s2MaskClouds = function (s2WithCloudProbability, maxCloudProbability) {
  function maskClouds(img) {
    var clouds = ee.Image(img.get('cloud_mask')).select('probability');
    var isNotCloud = clouds.lt(maxCloudProbability);
    return img.updateMask(isNotCloud);
  }
  
  // The masks for the 10m bands sometimes do not exclude bad data at
  // scene edges, so we apply masks from the 20m and 60m bands as well.
  // Example asset that needs this operation:
  // COPERNICUS/S2_CLOUD_PROBABILITY/20190301T000239_20190301T000238_T55GDP
  function maskEdges(s2_img) {
    return s2_img.updateMask(
        s2_img.select('B8A').mask().updateMask(s2_img.select('B9').mask()));
  }
  
  s2WithCloudProbability = s2WithCloudProbability.map(maskEdges);
  
  var s2CloudMasked = s2WithCloudProbability.map(maskClouds);
      
  return s2CloudMasked;
}

//cloud and shadow removal using the "Clear Sky" algorithm
//https://gis.stackexchange.com/questions/426571/cloud-shadow-removal-for-sentinel-2

exports.s2_clear_sky = function(image){
      var scl = image.select('SCL');
      var clear_sky_pixels = scl.eq(4).or(scl.eq(5)).or(scl.eq(6)).or(scl.eq(11));
      return image.updateMask(clear_sky_pixels);
    };

//------------------------------------------------------------------------------------
// Vegetation index functions...

/* Calculates and adds vegetation index bands to a S2 multi-band image.
 *
 * image - the image to add the NDVI/EVI band to.
 * returns - the image with an NDVI/EVI band added.
 */
 
exports.S2addNDVI = function (image) {
  var ndvi = image.normalizedDifference([constants.S2_NIR_BAND, constants.S2_RED_BAND]).rename(constants.NDVI_NAME);
  return image.addBands(ndvi);
}

exports.S2addEVI = function (image) {
  var EVI = image.expression(
      '2.5 * ((NIR - RED) / (NIR + 6 * RED - 7.5 * BLUE + 1))', {
      'NIR' : image.select(constants.S2_NIR_BAND).divide(10000),
      'RED' : image.select(constants.S2_RED_BAND).divide(10000),
      'BLUE': image.select(constants.S2_BLUE_BAND).divide(10000)}).rename(constants.EVI_NAME);
  return image.addBands(EVI);
};

exports.S2addEVI2 = function (image) {
  var EVI2 = image.expression(
      '2.4 * ((NIR - RED) / (NIR + RED + 1))', {
      'NIR' : image.select(constants.S2_NIR_BAND).divide(10000),
      'RED' : image.select(constants.S2_RED_BAND).divide(10000),
      'BLUE': image.select(constants.S2_BLUE_BAND).divide(10000)}).rename(constants.EVI2_NAME);
  return image.addBands(EVI2);
};

exports.S2AddIndices = function (image) {
  return exports.S2addNDVI(exports.S2addEVI(image));
}

exports.S2AddIndices2 = function (image) {
  return exports.S2addNDVI(exports.S2addEVI(exports.S2addEVI2(image)));
}

//------------------------------------------------------------------------------------
//Feature Collection Functions

/* Returns random entries of a feature collection corresponding to the provided percentage.
 * collection - feature collection from which to generate the random samples.
 * percentage - the percentage of the original to return.
 * returs - a feature collection of random entries corresponding to an amount equal to the procided percentage.
 */
exports.randomFeaturesByPercentage = function (collection, percentage) {
  var fc = collection.randomColumn();
  return fc.filter('random < ' + percentage.toString());
};

exports.randomFeaturesByCount = function (collection, numberOfFeatures) {
  var totalFeatures = collection.size().getInfo();
  var requiredPercentage = (numberOfFeatures/totalFeatures).toFixed(10);

  var randomFeatures = exports.randomFeaturesByPercentage(collection, requiredPercentage);

  return randomFeatures;
};

exports.featuresWithMostImages = function (featureCollection, imageCollection, sampleCount, desiredFeatureCount) {
  var imgNumKey = "num_imgs";
  return exports.randomFeaturesByCount(featureCollection, sampleCount)
  .map( function (feature) {
    return feature.set(imgNumKey, imageCollection.filterBounds(feature.geometry()).size());
  })
  .sort(imgNumKey, false)
  .limit(desiredFeatureCount);
}

//------------------------------------------------------------------------------------
//Visualization Functions

// Adopted from 
// https://developers.google.com/earth-engine/tutorials/community/modis-ndvi-time-series-animation
//
exports.animatedIndexURL = function (indexName, imageCollection, region, startDate, endDate) {
  var col = imageCollection.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year');
    return img.set('doy', doy);
  });
  
  // Make a day-of-year sequence from 1 to 365 with a 16-day step.
  var doyList = ee.List.sequence(1, 365);

  // Import the collection.
  var indexCol = col.select(indexName);
  var distinctDOY = indexCol.filterDate(startDate, endDate);
  // Define a filter that identifies which images from the complete collection
  // match the DOY from the distinct DOY collection.
  var filter = ee.Filter.equals({leftField: 'doy', rightField: 'doy'});
  
  // Define a join.
  var join = ee.Join.saveAll('doy_matches');
  
  // Apply the join and convert the resulting FeatureCollection to an
  // ImageCollection.
  var joinCol = ee.ImageCollection(join.apply(distinctDOY, indexCol, filter));
  // Apply median reduction among matching DOY collections.
  var comp = joinCol.map(function(img) {
    var doyCol = ee.ImageCollection.fromImages(
      img.get('doy_matches')
    );
    return doyCol.reduce(ee.Reducer.median());
  });
  
  // Animation setup
  // Define RGB visualization parameters.
  var visParams = {
    min: -1.0,
    max: 1.0,
    palette: [
      'FFFFFF', 'CE7E45', 'DF923D', 'F1B555', 'FCD163', '99B718', '74A901',
      '66A000', '529400', '3E8601', '207401', '056201', '004C00', '023B01',
      '012E01', '011D01', '011301'
    ],
  };
  
  // Create RGB visualization images for use as animation frames.
  var rgbVis = comp.map(function(img) {
    return img.visualize(visParams).clip(region);
  });
  
  // Define GIF visualization parameters.
  var gifParams = {
    'region': region.geometry(),
    'dimensions': 200,
    'crs': 'EPSG:3857',
    'framesPerSecond': 30
  };
  
  return rgbVis.getVideoThumbURL(gifParams)
}

exports.animatedImageURL = function (indexName, imageCollection, region, startDate, endDate) {
  var col = imageCollection.map(function(img) {
    var doy = ee.Date(img.get('system:time_start')).getRelative('day', 'year');
    return img.set('doy', doy);
  });
  
  // Make a day-of-year sequence from 1 to 365 with a 16-day step.
  var doyList = ee.List.sequence(1, 365);

  // Import the collection.
  var indexCol = col.select(indexName);
  var distinctDOY = indexCol.filterDate(startDate, endDate);
  // Define a filter that identifies which images from the complete collection
  // match the DOY from the distinct DOY collection.
  var filter = ee.Filter.equals({leftField: 'doy', rightField: 'doy'});
  
  // Define a join.
  var join = ee.Join.saveAll('doy_matches');
  
  // Apply the join and convert the resulting FeatureCollection to an
  // ImageCollection.
  var joinCol = ee.ImageCollection(join.apply(distinctDOY, indexCol, filter));
  // Apply median reduction among matching DOY collections.
  var comp = joinCol.map(function(img) {
    var doyCol = ee.ImageCollection.fromImages(
      img.get('doy_matches')
    );
    return doyCol.reduce(ee.Reducer.median());
  });
  
  // Animation setup
  // Define RGB visualization parameters.
  
 var visParams = {
  bands: ['B4_median', 'B3_median', 'B2_median'],
  min: 0,
  max: 3000,
};

  
  // Create RGB visualization images for use as animation frames.
  var rgbVis = comp.map(function(img) {
    return img.visualize(visParams).clip(region);
  });
  
  // Define GIF visualization parameters.
  var gifParams = {
    'region': region.geometry(),
    'dimensions': 250,
    'framesPerSecond': 10
  };
  
  return rgbVis.getVideoThumbURL(gifParams)
}

//------------------------------------------------------------------------------------
//Time Series and Phenological functions

//calculate number of images per season in an image collection

exports.numberOfImagesPerSeason = function (imageCollection, season_names, season_start_indices, startDate, endDate) {
  // create start index for each season
  
  var startIndexDict = ee.Dictionary.fromLists(season_names, season_start_indices);
  
   var years = ee.List.sequence(ee.Date(startDate).get('year'), ee.Date(endDate).get('year'));
   
    var seasonFunction = function(season_name) {
    return ee.List([season_name, years.map(function (year) { return annualFunction(year, season_name) }).reduce(ee.Reducer.sum())]);
  }
  
  var annualFunction = function  (year, season_name) {
    var startDate = ee.Date.fromYMD(year, startIndexDict.get(season_name), 1);
    var endDate = startDate.advance(3, "month");
    var dateRange = ee.DateRange(startDate, endDate);
    
    return imageCollection.filterDate(dateRange).size();
  }
   
  return season_names.map(seasonFunction)
}

exports.addDateTaken = function(image) {
  // Get the timestamp and convert it to a date.
var date = ee.Date(image.get('system:time_start'));
return image.set('readable_date', date);
};

  /*Function to create a lagged ImageCollection containing 
  //images from one collection and images in another 
  //collection, lagging by one day
  */

exports.lag = function(leftCollection, rightCollection, lagDays) {
  var filter = ee.Filter.and(
    ee.Filter.maxDifference({
      difference: 1000 * 60 * 60 * 24 * lagDays,
      leftField: 'system:time_start', 
      rightField: 'system:time_start'
    }), 
    ee.Filter.greaterThan({
      leftField: 'system:time_start', 
      rightField: 'system:time_start'
  }));
  
  return ee.Join.saveAll({
    matchesKey: 'images',
    measureKey: 'delta_t',
    ordering: 'system:time_start', 
    ascending: false, // Sort reverse chronologically
  }).apply({
    primary: rightCollection, 
    secondary: leftCollection, 
    condition: filter
  });
};

// exports.lag = function(leftCollection, rightCollection, lagDays) {
//   var filter = ee.Filter.and(
//     ee.Filter.maxDifference({
//       difference: 1000 * 60 * 60 * 24 * lagDays,
//       leftField: 'system:time_start', 
//       rightField: 'system:time_start'
//     }), 
//     ee.Filter.greaterThan({
//       leftField: 'system:time_start', 
//       rightField: 'system:time_start'
//   }));
  
//   return ee.Join.saveAll().apply({
//     primary: rightCollection, 
//     secondary: leftCollection, 
//     condition: filter
//   });
// };

// Function to calculate median index within the given geometry
exports.medianIndex = function (image, geometry) {
  // return ee.Dictionary();
  var stats = image.reduceRegion({
    reducer: ee.Reducer.median(),
    geometry: geometry,
    scale: 10,
    tileScale: 16
  });
  return stats;
}

// Function to select all images for the given month in a year and compute a median composite
exports.monthIndex = function (year, month, imageCollection) {
    var list = ee.List([]);
    var monthImages = imageCollection.filter(
     ee.Filter.calendarRange({start: year, field: 'year'})
     )
     .filter(
     ee.Filter.calendarRange({start: month, field: 'month'})
     );
  
   year = ee.Number(year).format('%d');
   month = ee.Number(month).format('%02d');
  
   var medianImage = monthImages.reduce(ee.Reducer.median());

    var name = year.cat('-').cat(month).cat('-01');

   medianImage = medianImage.set('date_range', name);
   list = ee.Algorithms.If(medianImage.bandNames().size().gt(0), 
   ee.List(list).add(medianImage), 
   list);

   return list;
  }

// Function to get the average of a band over a month in a supplied region
exports.getIndexmonthly = function (year, month, geometry, imageCollection) {
  
    // filter by bounds
    // var filtered = imageCollection.filterBounds(geometry);

  
  // // Function to select all images for the given month in a year and compute a median composite
  // var monthIndex = function (year, month, imageCollection) {
  //   var list = ee.List([]);
  //   var monthImages = imageCollection.filter(
  //   ee.Filter.calendarRange({start: year, field: 'year'})
  //   )
  //   .filter(
  //   ee.Filter.calendarRange({start: month, field: 'month'})
  //   );
  
  // year = ee.Number(year).format('%d');
  // month = ee.Number(month).format('%02d');
  
  // var medianImage = monthImages.reduce(ee.Reducer.median());

  //   var name = year.cat('-').cat(month).cat('-01');

  // medianImage = medianImage.set('date_range', name);
  // list = ee.Algorithms.If(medianImage.bandNames().size().gt(0), 
  // ee.List(list).add(medianImage), 
  // list);

  // return list;
  // }
   // Map the function over the list
   return exports.monthIndex(year, month, imageCollection, geometry);
}

// Function to get the average of a band over a month in a supplied region
exports.getIndexbimonthly = function (year, month, geometry, imageCollection) {
  // filter by bounds
  var filtered = imageCollection.filterBounds(geometry);
  
  // Function to select all images for the given month in a year and compute two median composites
 var bimonthIndex = function (year, month, imageCollection) {
  var list = ee.List([]);
  var monthImages = imageCollection.filter(
    ee.Filter.calendarRange({start: year, field: 'year'})
    )
    .filter(
    ee.Filter.calendarRange({start: month, field: 'month'})
    );
    
  var firstOfMonthImages = monthImages.filter(
    ee.Filter.calendarRange({start: 1, end: 15, field: 'day_of_month'})
    );
    
  var endOfMonthImages = monthImages.filter(
    ee.Filter.calendarRange({start: 15, end: 31, field: 'day_of_month'})
    );
  year = ee.Number(year).format('%d');
  month = ee.Number(month).format('%02d');
  
  var medianImage_1 = firstOfMonthImages.reduce(ee.Reducer.median());

  var name_1 = year.cat('-').cat(month).cat('-01');

  var medianImage_2 = endOfMonthImages.reduce(ee.Reducer.median());

  var name_2 = year.cat('-').cat(month).cat('-15');

  medianImage_1 = medianImage_1.set('date_range', name_1);
  list = ee.Algorithms.If(medianImage_1.bandNames().size().gt(0), 
  ee.List(list).add(medianImage_1), 
  list);
  medianImage_2 = medianImage_2.set('date_range', name_2);
  list = ee.Algorithms.If(medianImage_2.bandNames().size().gt(0), 
  ee.List(list).add(medianImage_2), 
  list);
  return list;
}

  // Map the function over the list
  // return bimonthIndex(year, month, imageCollection, geometry);
}

//function to create constant images median and st. dev as bands
exports.generateIndexCollection = function (indexName, imageCollection, fc) {
  
  //input can be feature or feature collection
  var feature = ee.Feature(fc.geometry());
  
  // // Function to calculate median index on an image within the geometry
  function medianIndex(image, geometry) {
    var stats = image.reduceRegion({
      reducer: ee.Reducer.median(),
      geometry: geometry,
      scale: 30,
      maxPixels:1e10
    });
    
      // set the veg index to -999 for null values
    stats = ee.List([stats.get(indexName), -999])
    .reduce(ee.Reducer.firstNonNull())

    return stats;
  }
  // Function to calculate standard deviation of index on an image within the geometry
  function sdIndex(image, geometry) {
    var stats = image.reduceRegion({
      reducer: ee.Reducer.stdDev(),
      geometry: geometry,
      scale: 30, 
      maxPixels: 1e10
    });
    
    // set the veg index to -999 for null values
    stats = ee.List([stats.get(indexName), -999])
          .reduce(ee.Reducer.firstNonNull())

    return stats;
  }
  // return a dictionary of the plot median and stdevs
  // for each image in the image collection 
  return imageCollection.map(function (image) {
      var time = image.get('system:time_start');
      var median = ee.Number(medianIndex(image, feature.geometry()));
      var median_image = ee.Image(median).double();
      var sd = ee.Number(sdIndex(image, feature.geometry()));
      var sd_image = ee.Image(sd).double();
      return ee.ImageCollection.fromImages([median_image, sd_image])
                     .toBands().set({time:time});
    });
};

