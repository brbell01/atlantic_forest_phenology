//Import helper scripts
var wrapper = require('users/brbell01/AF_Phenology:Sentinel-1/Wrapper');
var helper = require('users/brbell01/AF_Phenology:Sentinel-1/Utilities');
var helpers = require('users/brbell01/AF_Phenology:Helpers');
var constants = require('users/brbell01/AF_Phenology:Constants');

// Geometry Imports
var MataEscura_Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/1_MataEscura_Hectares1"),
    MontePascoal_Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/2_MontePascoal_Hectares1"),
    RioDoce_Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/3_RioDoce_Hectares1"),
    Sooretama_Hectares = ee.FeatureCollection("projects/af-phenology/assets/Hectares/4_Sooretama_Hectares1"),
    REBIO_Sooretama = ee.FeatureCollection("projects/af-phenology/assets/Parks/REBIO_Sooretama"),
    PNH_Monte_Pascoal = ee.FeatureCollection("projects/af-phenology/assets/Parks/PNH_Monte_Pascoal"),
    REBIO_Mata_Escura = ee.FeatureCollection("projects/af-phenology/assets/Parks/REBIO_Mata_Escura"),
    PE_Rio_Doce = ee.FeatureCollection("projects/af-phenology/assets/Parks/PE_Rio_Doce");

// Set study area and sampling plots
var AREA_NAME = 'PE Rio Doce, MG', // 'REBIO Sooretama, ES'
    FILE_NAME = 'rio_doce', // 'mata_escura', // 'monte_pascoal' , 'sooretama',
    Hectares = RioDoce_Hectares,
    Park = PE_Rio_Doce;

//choose which ratio to use for export and visualization
var vis_band_ratio = 'RVI' // VHVV_ratio' // or 'RVI'

// //For analysis of whole park, need to extract forest only layers
// var lulc = ee.Image("projects/af-phenology/assets/Mapbiomas_MG_LULC_2019");
// var filter = ee.Filter.and(
//     ee.Filter.bounds(PARK.geometry()), 
//     ee.Filter.eq('classification_2019',3));
// var park_forest = lulc.filter(filter);
// Hectares = park_forest;

// Define Sentinel-1 Parameters
var parameter = {//1. Data Selection
    START_DATE: "2016-01-01",
    STOP_DATE: "2017-01-01",
    POLARIZATION:'VVVH',
    ORBIT: 'DESCENDING',
    ORBIT_NUMBER: 155, //155, 82
    GEOMETRY: Park.geometry(),
    APPLY_ADDITIONAL_BORDER_NOISE_CORRECTION: true,
    //3.Speckle filter
    APPLY_SPECKLE_FILTERING: true,
    SPECKLE_FILTER_FRAMEWORK: 'MULTI',
    SPECKLE_FILTER: 'LEE SIGMA',
    SPECKLE_FILTER_KERNEL_SIZE: 15,
    SPECKLE_FILTER_NR_OF_IMAGES: 5,
    //4. Radiometric terrain normalization
    APPLY_TERRAIN_FLATTENING: true,
    DEM: ee.Image('USGS/SRTMGL1_003'),
    TERRAIN_FLATTENING_MODEL: 'VOLUME',
    TERRAIN_FLATTENING_ADDITIONAL_LAYOVER_SHADOW_BUFFER: 100,
    //5. Output
    FORMAT : 'DB',
    CLIP_TO_ROI: false,
    SAVE_ASSETS: false,
    //6. Visualization
    VIS_BAND_RATIO: vis_band_ratio // 'VHVV_ratio' // or 'RVI'
}

//Preprocess the S1 collection
var s1_preprocess = wrapper.s1_preproc(parameter);

var s1 = s1_preprocess[0];
s1_preprocess = s1_preprocess[1];

//Filter to consistent orbit number
s1 = s1.filter(ee.Filter.eq('relativeOrbitNumber_start', 
    parameter.ORBIT_NUMBER));

//print(s1,  "S1 collection - single orbit")

s1_preprocess = s1_preprocess.filter(ee.Filter.eq('relativeOrbitNumber_start', 
                parameter.ORBIT_NUMBER));

//print(s1_preprocess,  "ARD processed S1 collection - single orbit")

//Add ratio band   

var visparam = {}
if (parameter.POLARIZATION=='VVVH'){
      if (parameter.FORMAT=='DB'){
        if (parameter.VIS_BAND_RATIO=='VHVV_ratio') {
    var s1_preprocess_view = s1_preprocess.map(helper.add_ratio_lin).map(helper.lin_to_db3);
    var s1_view = s1.map(helper.add_ratio_lin).map(helper.lin_to_db3);
    visparam = {bands: ['VV', 'VH', parameter.VIS_BAND_RATIO],min: [-20, -25, 1],max: [0, -5, 15]}
        }
        else {
    var s1_preprocess_view = s1_preprocess.map(helper.add_rvi_lin).map(helper.lin_to_db3);
    var s1_view = s1.map(helper.add_rvi_lin).map(helper.lin_to_db3);
    visparam = {bands: ['VV', 'VH', parameter.VIS_BAND_RATIO],min: [-20, -25, 1],max: [0, -5, 15]}
        }
      }
      else {
      if (parameter.VIS_BAND_RATIO=='VHVV_ratio') {
    var s1_preprocess_view = s1_preprocess.map(helper.add_ratio_lin);
    var s1_view = s1.map(helper.add_ratio_lin);
    visparam = {bands: ['VV', 'VH', parameter.VIS_BAND_RATIO], min: [0.01, 0.0032, 1.25],max: [1, 0.31, 31.62]}
      }
      else {
    var s1_preprocess_view = s1_preprocess.map(helper.add_rvi_lin).map(lin_to_db3);
    var s1_view = s1.map(helper.add_rvi_lin).map(helper.lin_to_db3);
    visparam = {bands: ['VV', 'VH', parameter.VIS_BAND_RATIO],min: [-20, -25, 1],max: [0, -5, 15]}
      }
    }
}
else {
    if (parameter.FORMAT=='DB') {
    s1_preprocess_view = s1_preprocess.map(helper.lin_to_db);
    s1_view = s1.map(helper.lin_to_db);
    visparam = {bands:[parameter.POLARIZATION],min: -25,max: 0}   
    }
    else {
    s1_preprocess_view = s1_preprocess;
    s1_view = s1;
    visparam = {bands:[parameter.POLARIZATION],min: 0,max: 0.2}
    }
}

//print(s1_preprocess_view, "S1 ARD collection with Band Ratio");

//// Functions

var generateIndexChart = function(indexName, imageCollection, featureCollection, regionName) {

    // // Function to calculate average index within the given geometry
    function medianIndex(image, geometry) {
      var stats = image.reduceRegion({
        reducer: ee.Reducer.median(),
        geometry: geometry,
        bestEffort: true,
        scale: 10
      });
      
      return stats.get(indexName);
    }
    
        // // Function to calculate stdev of index within the given geometry
    function sdIndex(image, geometry) {
      var stats = image.reduceRegion({
        reducer: ee.Reducer.stdDev(),
        geometry: geometry,
        bestEffort: true,
        scale: 10
      });
      
      return stats.get(indexName);
    }
  
    //function to get a list of band values and respective dates in supplied regions
    function getAverageIndex(feature, imageCollection) {
      // filter by bounds
      var filtered = imageCollection//.filterBounds(feature.geometry());
      
      var averages = filtered.toList(1000).map(function (image) {
        image = ee.Image(image)
        var median = medianIndex(image, feature.geometry());
        var sd = sdIndex(image, feature.geometry());
        var date = image.date()
        return ee.List([date.format('y-M-d'), median, sd])
      })
      //.filter(ee.Filter.listContains('item', null).not())
      
      
      var propertyKey = indexName
      return feature.set(propertyKey, averages)
    }
    
    var meanIndices = featureCollection.map(function(feature) { return getAverageIndex(feature, imageCollection); })
    return meanIndices
  }
  
var hectaresImageIndices = generateIndexChart(constants.VV_NAME, s1_preprocess_view, Hectares, AREA_NAME);
  hectaresImageIndices = generateIndexChart(constants.VH_NAME, s1_preprocess_view, hectaresImageIndices, AREA_NAME);
  
if (vis_band_ratio == 'VHVV_ratio') {
  hectaresImageIndices = generateIndexChart(constants.VHVVratio_NAME, s1_preprocess_view, hectaresImageIndices, AREA_NAME);
}
else {hectaresImageIndices = generateIndexChart(constants.RVI_NAME, s1_preprocess_view, hectaresImageIndices, AREA_NAME);
}

print(hectaresImageIndices,  "Median Backscatter from 1-Ha Plots")

// use whole park
//MATA_ESCURA_HECTARES = ee.FeatureCollection(Park)

var year = ee.String(parameter.START_DATE).slice(0,4)

Export.table.toDrive({
  collection: hectaresImageIndices,
  description: FILE_NAME + '_s1_1ha_' + year.getInfo(),
  folder: 'phenology',
  fileFormat: 'GeoJSON',
  selectors: ['Hectare_ID', constants.VH_NAME, constants.VV_NAME, vis_band_ratio]
});