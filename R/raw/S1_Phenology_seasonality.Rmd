---
title: "S1 Seasonality"
author: "J. Bruce Bell"
date: "`r Sys.Date()`"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
knitr::opts_knit$set(root.dir = "/Users/brbell01/Google Drive/PHD/CUNY/Research/R/Phenology/")
```

Imports
```{r echo=FALSE}
library(knitr)
library(tidyr)
library(lubridate)
library(clock)
library(stringr)
library(dplyr)
library(ggplot2)
library(purrr)
library(data.table)
library(tibble)
library(sf)
library(tidyquant)
library(circular)
library(readr)
library(DescTools)
library(padr)
```

Setup
```{r}
#set working directory
wd <- getwd()
output_folder <- paste0(wd, "/combined/")

#Parameters to be altered
foresttype <- "Seasonal Semi-deciduous Forest"  # "Seasonal Semi-deciduous Forest"; "Broadleaf Evergreen"
studyarea <- "REBIO Mata Escura, MG"  #  "REBIO Mata Escura, MG" ; "PNH Monte Pascoal" 
study_site <-"sooretama" # "sooretama" # "rio_doce" # "monte_pascoal" # "mata_escura"

#other params
studyarea_bases <- c("mata_escura","monte_pascoal","rio_doce","sooretama")
band.list <- c("RVI", "VH", "VV")
```

Read in raw time series and process means
```{r}
indexdata <- vector(mode = "list", length = 0)
for (band in band.list) {
      table <- read.csv(paste0(wd, "raw/s1/1ha/second_run/", studyarea_base, "_s1_", band, "_1ha_processed.csv"))
      table <- table[,!names(table) %in% c("X")] %>% mutate(date = ymd(date))
      indexdata[[band]] <- table
}
plotdata <- list()
for (band in band.list) {
plotdata[[band]] <- indexdata[[band]] %>% gather("Hectare_ID", value, -date) %>%     
                         filter(!grepl('sd', Hectare_ID)) %>% group_by(Hectare_ID) %>% na.omit() %>% 
                         mutate(mean = mean(value), median = median(value)) %>%
                         mutate(Hectare_ID, meanlab = paste('Mean =', mean), medianlab = paste('Median =', median)) %>%
                         mutate(meanlab = substring(meanlab, 1, 13), medianlab = substring(medianlab, 1, 15))
}
```

Read in seasonality data.
(Run A (single harmonic modeled) or B (multiple harmonic modeled) to define "season_def")

A. (First run - generate seasonality table) Simple Harmonic Fit
```{r}
# Read in seasonality data from harmonic analysis
path <- paste0(wd, "/raw/s1/1ha/harmonic/")
files <- dir(path, full.names = T, pattern = "harmonic.csv")
S1_season <- files %>% map(read.csv, header=T)
#loop through and extract seasonality metrics for each file
for (file in 1:length(S1_season)) {
  fit_table <- S1_season[[file]]   # extract table from the file
  names(fit_table)[1] <- "Date"    # rename
  fit_table <- fit_table %>% mutate(Date = date_parse(Date, format = "%b %d, %Y")) #reformat date
  jan1 <- fit_table$Date %>% year %>% unique  # list of years
  date_breaks <- paste0(jan1, "-01-01") %>% as.Date()  # Jan. 1 of each year
  seasonality <- data.frame(matrix(NA, nrow=1, ncol=3))  # format a blank seasonality table to hold metrics
  dates <- matrix(rep("2017-01-01"),3) %>% t %>% data.frame() %>% mutate_all(as.Date)
  seasonality <- seasonality %>% cbind(dates)  # append date columns
  names(seasonality) <- c("season_start_val", "peak_val", "season_end_val", "season_start_date", "peak_date", "season_end_date") # col names
  seasonality <- seasonality[-1,] # remove dummy values
  for (year in 1:length(date_breaks)) {
      table <- fit_table %>% pad() %>% thicken(paste0(12, " days")) %>% select(-Date) %>%
               rename_at(ncol(.), ~"Date") %>% mutate(Date = Date+1) %>% relocate(Date) %>%
               pad() %>% filter(between(Date, date_breaks[year],  # pad again in case of incorrect padding interval
               # ifelse cases for all years and final year
               if_else(!is.na(date_breaks[year+1]), date_breaks[year+1], tail(fit_table$Date, n=1))))
      # unique values and remove NAs introduced by incorrect padding interval
      table <- table %>% group_by(Date) %>% arrange(.by_group = TRUE, desc(fitted)) %>% distinct(Date, .keep_all = TRUE)
      min <- min(table$fitted, na.rm=T) 
      min_date <- table %>% filter(fitted == min) 
      min_date <- first(min_date[[1]])  # enforce single value
      max <- max(table$fitted, na.rm=T) # get season peak value
      max_date <- table %>% filter(fitted == max)  # get season peak date
      max_date <- first(max_date[[1]]) # enforce single value
      if (min_date < max_date) {min_max <- table %>% filter(between(Date, min_date, max_date))
                                } else {min_max <- table %>% filter(between(Date, max_date, min_date))}
      # narrow season start window 
      mean <- Closest(min_max$fitted, (max + min)/2, na.rm = T)[1] # find season start value, enforce single value
      s_start <- min_max %>% filter(fitted == mean)  # get season start date
      s_start <- ifelse(!is.na(mean), s_start$Date, NA) %>% as.Date() #get season start date with case for final year
      #get season end date with case for final yr
      if (!is.na(mean) && max_date > s_start) {s_end <- max_date - s_start + max_date %>% as.Date()
        } else if (!is.na(mean) && max_date < s_start) {s_end <- s_start - max_date + min_date %>% as.Date() 
        } else {s_end <- NA}
      # find season end value, with final year case
      if (!is.na(mean)) {
        s_end_val <- fit_table %>% filter(between(Date, s_end-6, s_end+6))
        } else {s_end <- NA}
      if(!is.na(mean)) {  
        s_end_val <- s_end_val$fitted %>% mean # enforce single value
      } else {s_end_val <- NA}  
      seasonality[nrow(seasonality) + 1,] <- list(mean, max, s_end_val, s_start, max_date, s_end)
  }
  
  # Add variables
  seasonality <- seasonality %>% mutate("Seas." = seq(1:length(season_start_val)))
  seasonality <- seasonality %>% mutate("Ampl." = max-min)
  seasonality <- seasonality %>% 
                   mutate("length_days" = ifelse(season_start < season_end,       
                                  yday(season_end_date)-yday(season_start_date),                                  
                                  yday(season_end_date)+365-yday(season_start_date)))
  seasonality <- seasonality %>% mutate("phase" = peak_date - floor_date(peak_date, unit="year"))

  # write out seasonality file to disk
  study_site_names <- rep(c("mata_escura","monte_pascoal","rio_doce","sooretama"), each=length(band.list))
  band_list <- rep(band.list, length(study_site_names))
  write.csv(seasonality, paste0(path, study_site_names[[file]],"_S1_", band_list[[file]], "_seasonality_processed.csv"))
}
```

A. Simple Harmonic Fit
```{r}
# Read season data from Timesat output seasonality file
path <- "/raw/s1/1ha/harmonic"
study_siteID <- match(study_site,studyarea_bases)  # study site defined above

S1_season <- dir(paste0(wd, path), full.names = T, pattern = "seasonality_processed.csv") %>% map(read.csv, header=T)
S1_season[[study_siteID]] -> S1_season

#Seasonal determination from harmonic analysis for the study area
S1_season <- S1_season %>% mutate(stdoy = yday(paste0("1901-", month(season_start_date), "-", day(season_start_date))))
S1_season <- S1_season %>% mutate(enddoy = yday(paste0("1901-", month(season_end_date), "-", day(season_end_date))))

season_start <- seasonality$season_start_date %>% yday %>% mean
season_end <- seasonality$season_end_date %>% yday %>% mean
season_def <- c(0, season_start, season_end, 365)    # define season intervlas
if (season_start > season_end) {season_def[c(2,3)] <- season_def[c(3,2)]} # swap season start/end when season end wraps to following year
```

B. Multiple Harmonic Fit
```{r}
# Read season data from Timesat output seasonality file
path <- "/timesat/output/third_run/S1"
S1_season <- dir(paste0(wd, path), full.names = T, pattern = "seasonality_processed.csv") %>% map(read.csv, header=T)
S1_season[[studyarea_base]] -> S1_season

#Seasonal determination from harmonic analysis for the study area
S1_season <- S1_season %>% mutate(stdoy = yday(paste0("1901-", month(season_start_date), "-", day(season_start_date))))
S1_season <- S1_season %>% mutate(enddoy = yday(paste0("1901-", month(season_end_date), "-", day(season_end_date))))

season_start <- S1_season$stdoy %>% mean
season_end <- S1_season$enddoy %>% mean

season_def <- c(0, season_start, season_end, 365)     
```

Process data using season definition
```{r}

plotdata.stats <- plotdata %>% 
              mutate(day = yday(date)) %>%  #create a month factor
              mutate(season=cut(day, #create season factor
              breaks=season_def,  #define seasons by day of year 
              labels=c("wet","dry","wet"))) %>%  
              mutate(year = year(date)) %>%  #create a year factor
              mutate(Hectare_ID = substring(Hectare_ID, 14)) %>%
              group_by(Hectare_ID) %>%    #group and reorder ascending
              mutate(mean = mean(value, na.rm = TRUE)) %>% arrange(mean) %>%
             # mutate(sortorder = rep(seq(1:length(IDs)), length.out = length(Hectare_ID))) %>%
              ungroup()

plotdata.stats <- data.frame(value = plotdata.stats$value,      #rearrange
                             Hectare_ID = factor(plotdata.stats$Hectare_ID),
                             season = factor(plotdata.stats$season), 
                             year = factor(plotdata.stats$year)
#                             ,sortorder = factor(indexdata.stats$sortorder)
)
```


Plot seasonality by 1-ha plot
```{r}
#take a random sample 
selectedrows <- sample.int(plotdata.stats$Hectare_ID %>% unique() %>% length(), 30, replace = F)
plotdata.stats <- plotdata.stats[is.element(plotdata.stats$Hectare_ID, selectedrows),]

#plot seasonal comparison
xlabs <- plotdata.stats$Hectare_ID %>% unique() %>% as.character()
ylims <- c(-16,-10)
#check boxplots
colors = c("wet" = "blue", "dry" = "orange")
plotdata.stats %>% na.omit() %>% 
  ggplot(aes(y=value, x=Hectare_ID, color = season, fill = season)) + 
    geom_boxplot(outlier.size=0.5, outlier.colour = NULL, show.legend = FALSE) + 
    scale_fill_manual(values=c("blue", "orange")) +
    scale_color_manual(values=c("blue", "orange")) +
    scale_x_discrete(labels=xlabs) +
    ylab(paste0("Mean ", bandname, " index value (dB)")) +
    theme_minimal(base_size = 14) +
    theme(axis.text.x = element_text(angle = 90, vjust=0.5)) +
    ggtitle(paste0("Plot-wise seasonal comparison of mean annual ", bandname, " backscatter \n (Sentinel-1) for ",  
                   "30 randomly selected 1 ha",
    #     length(unique(plotdata$Hectare_ID)), " ", scale, 
         " plots, ", studyarea, ", Brazil"))
```

Save plot
```{r}
ggsave(paste0(studyarea_base, "_plotseasonal_s1_", bandname, ".png"), units="in", width=10, height=5, dpi=300, device = 'png')
```

Analysis of variance:season
```{r}
#fit the linear model 
fit <- lm(value ~ season*year*Hectare_ID, plotdata.stats, 
          contrasts = list(Hectare_ID = "contr.sum", year = "contr.poly"))
anova(fit) %>% kable(digits = 10) 
write.csv(anova(fit) , paste0(studyarea_base, "_anova_s1_", bandname, ".csv"))

```

```{r}
#plot histogram
hist(indexdata.mean$mean, breaks = 20, ylim = c(0,25), xlab= paste0("Mean ", bandname, " value (dB)"), ylab= "Number of days / year", main= paste0("\n\n Distribution of daily Sentinel-1 averaged ", bandname, " backscatter \n values for ", length(indexdata)-1, " 1-ha plots over ", foresttype, ",\n ", studyarea, ", Brazil (2016-2021)"), border=F, col="dark blue")

abline(h=seq(0,55,5), col="gray", lty="dotted")

ggsave(paste0(studyarea_base, "_histannual_s1.png"), units="in", width=10, height=5, dpi=300, device = 'png')
```

Prep data for statistical analysis by circular statistics
```{r}
#summarize by daily mean across years and samples 
indexdata.mean <- indexdata$VH %>% 
                  reshape::melt(id = "date") %>%
                  mutate(doy = ymd(paste0("1901-", month(date), "-", day(date))))  %>%
                  distinct() %>%
                  group_by(doy) %>%
                  summarize(mean = mean(value, na.rm = TRUE)) 

#append converted days % summarize by month
indexdata.mean <- indexdata.mean %>% 
                  mutate("VH_13" = ifelse(mean>=-13.011, 1, 0)) %>%
                  group_by(month(doy)) %>%
                  count(VH_13) %>% mutate("month" = `month(doy)`, "VH_count" = n) %>%
                  filter(VH_13==1) 
#                  select(month, VH_count)

vec.labels <- seq(ymd('2000-01-01'),ymd('2000-12-01'),by='months') %>% format('%b')
  
ggplot(data=indexdata.mean, aes(x=month, y=VH_count)) +
  coord_polar(theta='x', start = 0, direction=1) +
  geom_col(fill="light grey") +
  theme_minimal() +
  geom_text(aes(label = VH_count), color="blue") +
  scale_y_continuous("Number of days/month VH greater than -13.270") +
  scale_x_continuous(limits = c(0,12), breaks=seq(0,12), labels=c(vec.labels,".")) +
  theme(axis.text.y = element_blank(),
         axis.ticks.y = element_blank() )
#        axis.title.x = element_blank(),
#        axis.text.x = element_blank()) +
 # annotate(geom = "text",
#           x = 1:nrow(indexdata.mean),
#           y = min(indexdata.mean$VH_count),
#           label = indexdata.mean$month)

ggsave(paste0(studyarea_base,"_polar1.png"), units="in", width=10, height=5, dpi=300, device = 'png')
```

```{r}
#circular stats
#circular mean 

#circular median

#circular Kappa (measure of spread) - based on Von Mises Distribution

```

```{r}
#Rayleigh Test of Uniformity
rayleigh.test((x, mu = NULL)
## S3 method for class 'rayleigh.test'
print(x, digits=4, ...)

```

```{r}
#daily circular plot, using plot.circular

#format days as integer day of year
degree_days <- plotmeans$doy %>% format(format = "%j") %>% as.numeric()

#convert day (degrees) to radians and threshold EVI values
radian_days <- 2*pi*degree_days/365

#circular plot

#vec.breaks <- seq(from = pi/2, to = 2*pi, by = pi/2)
#pi.halfs <- c(paste(expression(pi), "/2"),
#  paste(seq(from = 3, to = 4, by = 2), "*" , expression(pi), "/2"))
#pi.fulls <- c(paste(expression(pi)),
#  paste(seq(from = 2, to = 2, by = 1), "*" , expression(pi)))
#vec.expr <- parse(text = c(rbind(pi.halfs, pi.fulls)))[1:4]
vec.expr <- c(0, pi/6, pi/3, pi/2, 2*pi/3, 5*pi/6, pi, 7*pi/6, 4*pi/3, 3*pi/2, 5*pi/3, 11*pi/6)

#plot, but can't seem to place gridlines at above intervals.. 
plot.circular(circular(plotmeans$radian_days, units="radians", template = NULL))
```

```{r}
#circular stats
#circular mean 

#circular median

#circular Kappa (measure of spread) - based on Von Mises Distribution



```

```{r}
#Rayleigh Test of Uniformity
rayleigh.test(x, mu = NULL)
## S3 method for class 'rayleigh.test'
print(x, digits=4, ...)

```

```{r}
#circular linear regression modeling from S1 & S2 data
lm.circular(..., type=c("c-c", "c-l"))
lm.circular.cc(y, x, order = 1, level = 0.05, control.circular = list())
lm.circular.cl(y, x, init = NULL, verbose = FALSE, tol = 1e-10, 
  control.circular = list())
# S3 method for lm.circular.cl
print(x, digits = max(3, getOption("digits") - 3), 
  signif.stars= getOption("show.signif.stars"), ...)
```


